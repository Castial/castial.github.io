<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> load和initialize的特殊之处 · Hyyy的技术博客</title><meta name="description" content="load和initialize的特殊之处 - Hyyy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hyyy的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/eee3fae14bec" target="_blank" class="nav-list-link">简书</a></li><li class="nav-list-item"><a href="https://github.com/castial" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">load和initialize的特殊之处</h1><div class="post-info">Oct 3, 2016</div><div class="post-content"><blockquote>
<p>在NSObject.h中提供了两个特殊的类方法，load和initialize。帮助我们进行类的加载和初始化。</p>
</blockquote>
<p>既然是进行类的加载和初始化的，那么它们的调用时机是什么，又有什么区别呢？我们一起来看下。</p>
<h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><p>我们先做以下实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Father is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Load.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son+Load is loaded&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iOSTest[1120:83646] Father is loaded</div><div class="line">iOSTest[1120:83646] Son is loaded</div><div class="line">iOSTest[1120:83646] Son+Load is loaded</div></pre></td></tr></table></figure>
<p>说明，一个类如果实现了<code>load</code>方法，那么调用该方法之前，会先找父类的<code>load</code>方法，然后在调用自己的<code>load</code>方法。</p>
<p>如果是这个类的<code>category</code>的话，那么会先调用自己的<code>load</code>方法，然后再调用<code>category</code>的<code>load</code>方法。</p>
<a id="more"></a>
<p>需要注意的事，<code>load</code>方法的本质是直接执行函数指针的，因此不像普通方法调用，会走<code>objc_msgSend</code>这套流程，<code>load</code>方法并不会走<code>objc_msgSend</code>这套流程，有兴趣的同学可以看下源码，这里就不讨论那么多了。</p>
<p>另外就是有关执行顺序的问题，<code>load</code>方法执行，先是父类方法执行，然后是子类，最后是<code>category</code>中的方法执行。如果是不相关的两个类中<code>load</code>方法的执行顺序，和<code>Build Phases</code>中的<code>Compile Sources</code>文件顺序有关，放在前面的先执行。</p>
<p>还有一点很关键，<code>load</code>方法只会被调用一次，<code>initialize</code>也是的。</p>
<p>对于<code>load</code>方法的实践，大多是基于它开发中调用时间最早的特性。目前用的最多的就是Method Swizzling。比如经常用的Controller方法替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line"></div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        // When swizzling a class method, use the following:</div><div class="line">        // Class class = object_getClass((id)self);</div><div class="line">        // ...</div><div class="line">        // Method originalMethod = class_getClassMethod(class, originalSelector);</div><div class="line">        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        BOOL didAddMethod =</div><div class="line">            class_addMethod(class,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>不过，除了Method Swizzling，其他的东西还是少放，调用<code>load</code>方法的时候环境并不安全，也不要放线程堵塞的代码上去。</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>一样，我们先做个实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Load is initialized&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们什么先都不做，运行可以发现，什么都没打印。于<code>load</code>不同，<code>initialize</code>是惰性的，只会在第一次调用类的方法时去调用。</p>
<p>然后我们在修改一下上面的代码，去掉category那块，然后在主函数里创建一个Father对象，查看打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Father *father = [[Father alloc] init];</div></pre></td></tr></table></figure>
<p>运行可以发现，控制台打印出了一条，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div></pre></td></tr></table></figure>
<p>然后，我们修改主函数，创建一个Son对象，运行之后发现，打印了两条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son is initialized</div></pre></td></tr></table></figure>
<p>可以看到，创建子类对象会调用父类的<code>initialize</code>方法，并且是先执行父类的，然后执行子类的。那么我们可以得出，<code>initialize</code>方法的执行顺序是先执行父类的，然后执行子类的。</p>
<p>接下来我们还原代码，添加上catagory那块，在main函数里创建一个Son对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Initialize is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>运行后，发现，控制台仍然只打印了两条日志，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>关键点来了，我们发现，和<code>load</code>方法不一样，并没有打印三条日志，并且没有打印出Son子类的<code>initialize</code>方法。这是比较关键的，是因为<code>initialize</code>方法只会在第一次调用当前类的时候被调用，并且只会调用一次。既然走了Son的category的方法，那么就并不会走其本身的<code>initialize</code>方法了。</p>
<p>接下来我们继续修改代码，在主函数里多创建几个Son对象，发现日志没有变化，仍旧只是两条打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>这说明<code>initialize</code>方法只会走一次，这块和<code>load</code>方法还是有点像的。</p>
<p>一般<code>initialize</code>的使用场景比较少，如果需要在类调用前需要定义一些常量，可以在这里做。并且<code>initialize</code>方法内部也是线程安全的，这个也很关键。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/11/16/有关Block的一点总结/" class="prev">PREV</a><a href="/2016/04/21/Swift学习之闭包/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'hyyyblog';
var disqus_identifier = '2016/10/03/load和initialize的特殊之处/';
var disqus_title = 'load和initialize的特殊之处';
var disqus_url = 'http://yoursite.com/2016/10/03/load和initialize的特殊之处/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//hyyyblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Hyyy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>