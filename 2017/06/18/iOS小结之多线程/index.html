<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS小结之多线程 · Hyyy的技术博客</title><meta name="description" content="iOS小结之多线程 - Hyyy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hyyy的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/eee3fae14bec" target="_blank" class="nav-list-link">简书</a></li><li class="nav-list-item"><a href="https://github.com/castial" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS小结之多线程</h1><div class="post-info">Jun 18, 2017</div><div class="post-content"><blockquote>
<p>小结第三篇，来总结总结iOS中多线程操作。</p>
</blockquote>
<h3 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h3><p>对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。</p>
<p>谈细节之前里，我们得说下有关多线程的几个概念。</p>
<h4 id="串行和并发"><a href="#串行和并发" class="headerlink" title="串行和并发"></a>串行和并发</h4><p>串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如<code>NSDictionary</code>就是线程安全的，可以在多线程中使用它，不会出现问题，而<code>NSMutableDictionary</code>是线程不安全的，所以使用<code>NSMutableDictionary</code>的时候应该保证每次只能有一个线程访问它。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。</p>
<a id="more"></a>
<h3 id="iOS多线程方案"><a href="#iOS多线程方案" class="headerlink" title="iOS多线程方案"></a>iOS多线程方案</h3><h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h4><p><code>Pthreads</code>是基于C语言的通用多线程API，在日常开发中基本上用不到，并且目前在Swift中貌似并不能直接调用这套API。所以这种方案只提一下，不过多介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p><code>NSThread</code>是一套比较轻量级的多线程方案，可以直观地控制线程对象，一个<code>NSThread</code>代表一条线程，但是需要自己管理线程的生命周期，线程同步等问题，</p>
<p>创建thread目前所了解到的有4种方式，其中类方法两个，实例方法两个。类方法创建线程后会自动启动该线程，而实例方法只会创建线程，启动需要手动去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 第一种类方法</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadHandler) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">- (void)threadHandler &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二个类方法</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;block current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>下面是两种实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 第一个实例方法</div><div class="line">NSThread *thread1 = [[NSThread alloc] initWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[thread1 start];</div><div class="line"></div><div class="line">// 第二个实例方法</div><div class="line">NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(threadHandler:) object:@&#123;@&quot;title&quot; : @&quot;2123&quot;&#125;];</div><div class="line">[thread2 start];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的之外，<code>NSThread</code>还提供了一个<code>NSObject+NSThreadPerformAdditions</code>，用于在NSObject中执行线程调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在主线程执行一个任务，后者区别在于可以指定在哪种Runloop模式下运行，有关Runloop可以参考上篇文章。</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在指定的线程中执行一个任务。</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在后台隐形创建线程，执行一个任务</div><div class="line">[self performSelectorInBackground:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125;];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，NSThread还提供了设置线程优先级功能，叫做NSQualityOfService，一共分为一下几种：</p>
<ul>
<li>NSQualityOfServiceUserInteractive。用于用户交互，最高优先级</li>
<li>NSQualityOfServiceUserInitiated。用于执行需要立即返回的的任务，次高优先级</li>
<li>NSQualityOfServiceDefault。线程默认优先级</li>
<li>NSQualityOfServiceUtility。用于执行普通任务，普通优先级</li>
<li>NSQualityOfServiceBackground。最低优先级，用于执行不重要的任务</li>
</ul>
<p>还有其他一些线程操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 线程休眠，休眠线程会阻塞当前线程</div><div class="line">[NSThread sleepForTimeInterval:5.0];</div><div class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:5.0]];</div><div class="line"></div><div class="line">// 线程取消，调用此方法并不会马上停止线程运行，只仅仅是线程状态记录</div><div class="line">[thread cancel];</div><div class="line"></div><div class="line">// 线程停止，执行此方法会立即终止主线程外其他所有线程，所以调用请慎用。</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">// 获取当前线程</div><div class="line">[NSThread currentThread];</div><div class="line"></div><div class="line">// 获取主线程</div><div class="line">[NSThread mainThread];</div><div class="line"></div><div class="line">// 停止当前线程的Runloop</div><div class="line">CFRunLoopStop(CFRunLoopGetCurrent());</div></pre></td></tr></table></figure>
<p>如果有多个线程共享一块资源，对资源进行操作时候，还涉及到线程同步问题，一段时间只允许一条线程来操作资源，不然会引起冲突，iOS实现线程加锁有NSLock和@synchronized两种方式。其用法也比较简单，在这里就不过多介绍。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD全称是Grand Central Dispatch，是为了给iOS和mac的多核硬件上执行支持，其实现方式是一套底层C API。通过GCD，开发者不用和线程打交道，只需要使用一个Block就可以实现多线程操作。GCD提供的API简单易懂，提供了一个易于使用的并发模型，对于开发者来说，并不需要关心多线程的并发问题，GCD底层自动处理这些逻辑。</p>
<p>出了这些之外，GCD其实还可以根据当前的系统负载来增减线程数量，我们都知道线程的创建切换都是需要代价的，是有消耗的，所以使用GCD还可以增加效率，提供更高的性能。</p>
<p>GCD操作是需要通过队列来操作的，有三种队列可以使用。</p>
<ul>
<li>串行队列(Serial)。串行队列的特点是以先进先出的顺序来执行的，队列内的东西是以顺序执行的，但是多个串行队列直接是以并发执行的。</li>
<li>并行队列(Concurrent)。并行队列和串行队列相反，可以同时执行多个任务，但是多个任务之间，仍然是以先进先出的顺序执行的，区别在于，并行队列会跟酒系统负载，尽可能多地创建线程去执行这些任务。但是哪个任务先执行完毕是不确定的。</li>
<li>主线程队列(Main dispatch queue)。实际上，主线程队列是一个和主线程相关的串行队列。这个队列中的任务每次只会有一个执行。可以保证所有的任务都会在主线程执行，所以涉及到UI操作的需要使用这个队列来完成。</li>
</ul>
<p>创建一个串行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(@&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">// 这种也可以，NULL默认就是串行</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div></pre></td></tr></table></figure>
<p>创建一个并行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;coml.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 也可以用下面这种</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div></pre></td></tr></table></figure>
<p>主线程队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>GCD往队列里添加任务有两种方式，一种是异步，一种是同步。</p>
<ul>
<li>异步(dispatch_async)。是一个异步添加操作，dispatch_async会立即返回；</li>
<li>同步(dispatch_sync)。是一个同步添加操作，dispatch_sync区别是会阻塞当前线程，会等待block里的任务执行完毕之后才会返回。</li>
</ul>
<p>dispatch_async添加任务，会立即返回，所以下面的打印顺序不确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果：</div><div class="line">ThreadTest[17614:2597588] ========2</div><div class="line">ThreadTest[17614:2597588] ========1</div></pre></td></tr></table></figure>
<p>如果是dispatch_sync，由于是同步，所以打印结果是有顺序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果</div><div class="line">ThreadTest[17599:2595130] ========1</div><div class="line">ThreadTest[17599:2595130] ========2</div></pre></td></tr></table></figure>
<p>但是dispatch_sync尽量少用，使用不当会造成死锁。比如下面的代码就会造成死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    NSLog(@&quot;这里死锁了&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是，死锁并不是这里使用了主线程造成的，不用主线程，照样可以造成死锁。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.hyyy.thread&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">NSLog(@&quot;========1&quot;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_sync(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;========3&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种也会发生死锁，所以不要听信什么主线程的问题，不是主线程照样可以发生死锁。死锁真的发生的原因是dispatch_sync添加进的queue队列是当前queue队列。在主线程死锁的那段代码中，我们调用的dispatch_sync是添加在主线程queue中，使主线程堵塞，而我们的Block又需要主线程queue来执行，所以相互等待，造成死锁了。</p>
<p>但是为什么添加队列换成并行队列就不会有问题呢？还是上面的概念，对于并行队列中任务的执行，其执行开始和结束并不取决于上一个任务的结束时间，只仅仅取决于任务的耗时。即便任务是以同步的方式添加进去，但是在并行队列中也会在另外一个线程去跑这个任务。</p>
<p>这里还需要提一个题外话，在并发队列里的Block何时执行，开发者是不用知道的，完全取决于GCD，但是我们也是有方法可以让其按照顺序执行。</p>
<p>GCD的使用场景有很多，我们一个一个举例来说明。</p>
<p><strong>后台下载显示图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    NSURL * url = [NSURL URLWithString:@&quot;http://www.yourimage.com&quot;];</div><div class="line">    NSError * error;</div><div class="line">    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    if (data != nil) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.imageView.image = [UIImage imageWithData:data];</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;error when download:%@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个经典的使用场景，有时候我们需要后台处理一个任务，然后在主线程进行UI渲染，可以这么干。</p>
<p><strong>单例模式</strong></p>
<p>单例模式是设计模式中最简单的一种了，它的目的是创建的类对象在系统中是唯一的，一个类只有一个实例，节约系统资源。一般我们创建一个单例会这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//Singleton.h</div><div class="line">@interface Singleton : NSObject</div><div class="line">+ (Singleton *)sharedInstance;</div><div class="line">@end</div><div class="line"></div><div class="line">//Singleton.m</div><div class="line">@implementation Singleton</div><div class="line">static Singleton * sharedSingleton = nil;</div><div class="line">+ (Singleton *) sharedInstance &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedSingleton;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里我们用到了dispatch_once_t，对于给定的token来说，Block里的代码必定会执行，并且会仅执行一次。最重要的一点是，这里的操作是线程安全的，十分高效。但是需要注意的是token这个东西是应该声明称static或者global，这样来保证每次传进去的token是相同的。</p>
<p><strong>dispatch_after延后执行</strong></p>
<p>dispatch_after可以做到使一块代码延时执行，但是需要注意的是，这里的延时是有歧义的，dispatch_after做到的仅是延时把这一项任务提交到队列中去，至于什么时候执行，是和GCD内部处理逻辑有关的。</p>
<p>比如我想0.5秒之后发送一条通知，可以这么干。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:HY_AFTER_NOTIFICATION object:nil];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>dispatch_apply快速迭代</strong></p>
<p>dispatch_apply和遍历的效果差不多，其作用是把指定次数的block添加到queue中，好处是dispatch_apply可以不用管理线程方面的问题，GCD会自动处理并发现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    NSString *str = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %@&quot;, str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>Dispatch_groups</strong></p>
<p>Dispatch_groups作用是用来监视多个并行任务的执行，来进行线程同步的。在多个任务执行完毕后，想要执行结束处理，就可以使用Dispatch_groups来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue2, ^&#123;</div><div class="line">    NSLog(@&quot;========3&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">========3</div><div class="line">========1</div><div class="line">========2</div><div class="line">========end</div></pre></td></tr></table></figure>
<p>可以看到，上面三个任务执行完毕之后，才会走最后一个block回调，我们可以利用这种模式做很多事。但是千万不要像下面这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========1&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========2&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这么写会有问题，dispatch_group_async里执行的是异步任务，而dispatch_group_notify并不会等待异步任务完成，如果真的这么做，那就需要dispatch_group_enter和dispatch_group_leave来进行约束，也是我用的比较多的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的事，dispatch_group_enter和dispatch_group_leave总是对应出现的，类似于引用计数原理，有加有减。</p>
<p><strong>dispatch_barrier并发问题</strong></p>
<p>在并行队列里，有时候我们需要每次只单独执行一个任务，也就是当有个任务执行的时候，不允许其他任务执行，类似于多线程读写问题，这时候Dispatch Barrier就发挥了作用。</p>
<p>Dispatch Barrier可以保证提交的block是指定队列里某个时段唯一执行的一个，下面用一个示例来演示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">//等待前面的都完成，在执行barrier后面的</div><div class="line">dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;写数据&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:1];</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:1.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在进行写数据的时候，因为使用了Dispatch Barrier，不会发生读数据的操作，所以保证了每次写入数据只会有一个任务在执行。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>相比于GCD，NSOperation显得并没有那么流行，但是称得上是先进的面向对象的多线程解决办法。同样，对于开发者来讲，我们根本不用考虑线程的生命周期、同步，加锁等晦涩问题。</p>
<p>使用NSOperation有三种方式，NSInvocationOperation、NSBlockOperation和自定义子类继承NSOperation。</p>
<p><strong>NSInvocationOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>NSInvocationOperation默认情况下，并不会新开一个线程去跑，而是在当前线程去执行任务，可以将NSInvocationOperation放到NSOperationQueue中，即可实现异步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000077140&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x60800006e440&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p><strong>NSBlockOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>和NSInvocationOperation一样，默认NSBlockOperation只会在当前线程上执行。如果需要新开线程操作，可以添加到NSOperationQueue中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60800007d7c0&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000767c0&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>另外，可以使用addExecutionBlock添加额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000771c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000264280&gt;&#123;number = 5, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000260980&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000002640c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用addExecutionBlock会在新线程中去执行。但是并不是每次都会创建，我们可以试下多创建几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000071bc0&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000072040&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000000706c0&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>所以，如果NSBlockOperation封装的操作数大于1的时候,才会执行异步操作.不然也是在当前线程下执行的。</p>
<p>另外，NSOperation可以取消的，这个算是一大特色了，也是NSOperation的使用场景之一了。NSOperation有三种状态，isReady -&gt; isExecuting -&gt; isFinish， 如果在Ready的状态中对NSOperation进行取消，NSOperation会进入Finish状态。但是Operation已经开始执行了，就会一直运行到结束，或者由我们进行取消。也就是说Operation已经在executing状态，我们调用cancle方法系统不会中止线程的，这需要我们在任务过程中检测取消事件，并中止线程的执行，还要注意一点我们要释放内存或资源。</p>
<p>需要注意的是，调用cancel并不会退出线程，需要自行终止线程的运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![operation isCancelled]) &#123;</div><div class="line">    [operation cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有，NSOpertion可以设置优先级，从而改变其执行顺序，我们举个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1后执行&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2先执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 addDependency:operation2];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2先执行</div><div class="line">operation1后执行</div></pre></td></tr></table></figure>
<p>但是不能互相添加依赖，不然就死锁了，两个永远都不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[operation1 addDependency:operation2];</div><div class="line">[operation2 addDependency:operation1];</div></pre></td></tr></table></figure>
<p>有些时候，我们需要监听到任务完成后的回调事件，NSOperation也提供了这个方法，叫CompletionBlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation2 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2执行</div><div class="line">operation1执行</div><div class="line">operation2执行完毕</div><div class="line">operation1执行完毕</div></pre></td></tr></table></figure>
<p>还有自定义NSOperation，由于不是经常能用到，所以就不多做介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS多线程就总结到这里了，不过一般开发中用的GCD比较多，偶尔会用到NSOperation，这两个理解了就够用了，根据需求来定技术方案。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/11/iOS小结之Runloop/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'hyyyblog';
var disqus_identifier = '2017/06/18/iOS小结之多线程/';
var disqus_title = 'iOS小结之多线程';
var disqus_url = 'http://yoursite.com/2017/06/18/iOS小结之多线程/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//hyyyblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Hyyy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>