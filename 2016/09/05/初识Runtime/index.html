<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 初识Runtime · Hyyy的技术博客</title><meta name="description" content="初识Runtime - Hyyy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hyyy的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/eee3fae14bec" target="_blank" class="nav-list-link">简书</a></li><li class="nav-list-item"><a href="https://github.com/castial" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">初识Runtime</h1><div class="post-info">Sep 5, 2016</div><div class="post-content"><h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h3><p>面向对象的语言有很多种，比如Java、C++和Objective-C。但是面向对象的语言分两种，一种是函数调用型，另一种是消息结构型。其中Java和C++属于函数调用型，而OC属于消息结构型。为了支持消息结构，OC和其他语言不同的是，不仅仅只有一个编译器，还存在一个叫做runtime组件的东西，它的出现目的是简化编译器的功能，在OC中，基本的重要功能都是runtime组件完成的，所有的内存管理方法，对象所需的数据结构和方法都在其中。</p>
<p>这么一来，我们只需要更新runtime组件，就可以达到修改应用功能，我们使用的JSPatch、Aspects就是利用了这一功能。如果要在函数调用型语言上完成这些事，由于这些工作是在编译期完成的，所以必须重新编译代码才能完成。</p>
<p>在我们平时编写OC代码时，其实已经有意无意在和runtime打交道了，比如：</p>
<ul>
<li>平时写的类和方法，并且使用它们，其实runtime已经在悄悄地给我们提供支持；</li>
<li>当我们使用到<code>isKindOfClass</code>、<code>isMemberOfClass</code>、<code>conformsToProtocol</code>和<code>respondsToSelector</code>这些方法时，其实就是在调底层runtime的API；</li>
</ul>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>Objective-C类是用Class类型表示的，实际上是一个指向<code>objc_class</code>结构体的指针。打开<code>objc.h</code>即可看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>
<p>点进<code>objc_class</code>，可以看到该结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;     // 父类</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;     // 类名</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     // 类的版本信息，默认为0</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     // 类信息，提供运行时使用一些标示位</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     // 类的实例变量大小</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="ISA指针"><a href="#ISA指针" class="headerlink" title="ISA指针"></a>ISA指针</h4><p>打开<code>NSObject.h</code>文件，查看interface，我们可以看到下面这个定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，基类<code>NSObject</code>只有这么一个成员变量，我先看下官方是怎么定义的：</p>
<blockquote>
<p>Every object has an isa instance variable that identifies the object’s class. The runtime uses this pointer to determine the actual class of the object when it needs to.（简单翻译：每个对象都有一个isa变量来标示实例对象，当需要使用到这个对象时，runtime使用isa指针来确定是哪个实例对象）</p>
</blockquote>
<p>那么我们可以得出，每个对象都会有个isa指针，并且指向该对象的类。也就是isa指针是用来作为对象标示的。</p>
<p>但是，当我们查看<code>Class</code>结构时，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;     // 父类</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;     // 类名</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     // 类的版本信息，默认为0</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     // 类信息，提供运行时使用一些标示位</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     // 类的实例变量大小</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>我们看到，<code>objc_class</code>里面也有一个isa指针，那么这个isa指针是干什么的呢？在OC中，类也是一个对象，那可以这么说，类也是另外一个类的实例，这个类叫做<code>metaclass</code>，中文叫元类。元类保存类方法列表，就是说，当我们去调用一个类方法时，先会在元类中找，如果没有找到，则会在元类的父类中找。</p>
<p>那么问题来了？元类的isa指针指向哪里呢？所有的元类的isa指针都会指向一个根元类，同时根元类的isa指针指向自己。</p>
<p>关于这里的资料，推荐唐巧大哥的博客<a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a>，有关isa详细的介绍，可以参考参考。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在<code>objc_class</code>结构体中，有下面一条定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div></pre></td></tr></table></figure>
<p>ivars值包含了类的所有成员变量，每个元素里面是一个Ivar。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_ivar *Ivar;</div></pre></td></tr></table></figure>
<p>有关Ivar，也是一个结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar &#123;</div><div class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</div><div class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_ivar</code>里定义了成员变量的名称、类型和偏移字节。有关偏移字节的介绍，可以查看<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="external">Objective-C类成员变量深度剖析
</a>，说的很好，同时也回答了<code>为什么Objective-C类不能动态添加成员变量？</code>这个问题。</p>
<h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><p>在Class的定义里，有一个关于方法的属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div></pre></td></tr></table></figure>
<p>顾名思义，<code>methodLists</code>内包含的是该对象的方法列表。我们查看<code>objc_method_list</code>的介绍，可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct objc_method_list &#123;</div><div class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    int method_count                                         OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了一些基本介绍之外，最底部有个<code>objc_method</code>的属性，这个结构体就是用来定义方法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面有三个属性，SEL、方法类型和IMP。最重要的两个SEL和IMP，一个是查找方法的，另一个是实现方法的。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>我们先来看下<code>SEL</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>在Objective-C的编译过程中，会根据每一个方法的名字、参数序列来生成一个唯一的整型标示，这个标示就是SEL。我们可以用下面的代码获取到SEL，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SEL selector = @selector(eat);  // eat是一个Person类里的方法名</div><div class="line">NSLog(@&quot;SEL: %p&quot;, selector);</div><div class="line"></div><div class="line">// output: SEL: 0x1049748ee</div></pre></td></tr></table></figure>
<p>在Objective-C中，只要两个方法名相同，那么方法的SEL就是一样的。每一个方法对应一个SEL，同一个类中不能存在两个同名的方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Person.h</div><div class="line"></div><div class="line">- (void)showMessage:(NSString *)message;</div><div class="line">- (void)showMessage:(NSDictionary *)message;</div><div class="line"></div><div class="line">//Error: Duplicate declaration of method &apos;showMessage:&apos;</div></pre></td></tr></table></figure>
<p>拥有两个同名的方法，Xcode就会提示你重复声明方法而报错，但是，在不同类中使用同名的方法是不会报错的，并且其SEL也是一样的。</p>
<p>有关SEL的更多介绍，希望放到消息发送那块去讲，了解这些基础就可以了。</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP叫做函数指针，指的是方法实现的首地址。前面说了，查找方法通过SEL去查找对应的IMP，获取到IMP后，我们就获取到了方法实现的首地址了，也就是执行方法的入口，这样，我们就可以像调用C语言函数一样，去调用Objective-C的方法了。</p>
<p>SEL和IMP说完之后，我们回到Method上，Method结构体中包含一个SEL和IMP，相当于在SEL和IMP之间作了一个映射。每个方法都有自己的唯一标示和方法地址，执行起来效率最高。具体细节到消息发送那块去讲。</p>
<h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>在Class的定义中，有一行是关于方法缓存的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div></pre></td></tr></table></figure>
<p>打开<code>objc_cache</code>，我们可以看到其结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_cache &#123;</div><div class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</div><div class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个类只有一份方法缓存，当第一次方法被调用之后，再次调用的时候，就会优先从缓存列表中查找，如果没有的话，才会从methodLists中查找。</p>
<h3 id="协议列表"><a href="#协议列表" class="headerlink" title="协议列表"></a>协议列表</h3><p>Class定义中还有一个协议列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div></pre></td></tr></table></figure>
<p>查看<code>objc_protocol_list</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list &#123;</div><div class="line">    struct objc_protocol_list *next;</div><div class="line">    long count;</div><div class="line">    __unsafe_unretained Protocol *list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>顾名思义，其中包含了该Class的所有协议列表。我们可以使用<code>class_copyProtocolList</code>获取所有的<code>Protocol</code>。</p>
<h3 id="静态调用和动态调用"><a href="#静态调用和动态调用" class="headerlink" title="静态调用和动态调用"></a>静态调用和动态调用</h3><p>在说Objective-C的消息机制之前，我们先来看下在C中是如何进行函数调用的，在C语言中，函数调用属于静态绑定，意思就是在编译期间就可以获取到函数调用指令，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;eat\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void rest() &#123;</div><div class="line">    printf(&quot;rest\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doSomeThing(int type) &#123;</div><div class="line">    if (type == 0) &#123;</div><div class="line">        eat();</div><div class="line">    &#125;else &#123;</div><div class="line">        rest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    doSomeThing(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种函数调用，在编译期间就可以确定函数调用指令，所以为静态调用，下面我们换一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;eat\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void rest() &#123;</div><div class="line">    printf(&quot;rest\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doSomeThing(int type) &#123;</div><div class="line">    void (*method)();</div><div class="line">    if (type == 0) &#123;</div><div class="line">        method = eat;</div><div class="line">    &#125;else &#123;</div><div class="line">        method = rest;</div><div class="line">    &#125;</div><div class="line">    method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    doSomeThing(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二个和第一个区别在于，第二个只有在运行的时候，才会知道method方法到底指的是哪个，这就使用到了简单的动态调用了，因为需要在运行的时候才会知道method函数调用指令。</p>
<p>在Objective-C中，所有的函数调用，我们叫做发送消息，所谓的发送消息，就是指使用动态绑定技术在运行时决定需要调用的函数指令。所以我们经常说Objective-C是一门动态语言。</p>
<h3 id="objc-msgSend-消息分发"><a href="#objc-msgSend-消息分发" class="headerlink" title="objc_msgSend(消息分发)"></a>objc_msgSend(消息分发)</h3><p>当我们使用Objective-C进行方法调用时，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person doSomething];</div></pre></td></tr></table></figure>
<p>通俗地讲，我们使用面向对象的思维去解释的话，是<code>person</code>对象调用<code>doSomething</code>方法。但是如果从runtime的角度去看，其实是一个函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(person,doSomething);</div></pre></td></tr></table></figure>
<p>通俗地讲，就是在Objective-C中，我们进行方法调用的时候，其实是runtime使用<code>objc_msgSend</code>帮助我们发送一个消息，来帮助我们需要调用的方法。</p>
<p>然后，<code>objc_msgSend</code>会负责分发这个消息，它会查找合适的函数指针或者IMP，然后调用该函数，任何通过<code>objc_msgSend</code>传递的参数，最终都会变成IMP的参数。<code>objc_msgSend</code>的职责范围是接收参数，然后找到函数指针，进行分发。就像一个快递员一样，根据快递单号和地址，将快递从一个地方送到另外一个地方。</p>
<p>当然，为了提升速度，runtime还提供了方法缓存来加快查找速度。</p>
<p>我们把流程总结一下：</p>
<ol>
<li>[person doSomething];</li>
<li>objc_msgSend(person,@selector(doSomething));</li>
<li>objc_msgSend会进行消息分发，先是从cache中去查找，cache是一个hash表，Selector是key；</li>
<li>如果cache中没有找到，那么再去methodLists去找，如果找到，就会把它放到缓存中去，下次就不用直接查表了;</li>
<li>如果在methodLists中都没找到，那么会去superClass中去找，直到最顶端的根类；</li>
<li>如果到根类都没有找到的话，那么就会报<code>unrecognized selector sent to instance 0x7fe672452350</code>这个异常。</li>
</ol>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>上面，我们看到，如果找不到的话，就会报异常，<code>unrecognized selector sent to instance 0x7fe672452350</code>，在这个异常抛出之前，会试图通过三种途径来拯救异常。</p>
<ol>
<li>Method resolution</li>
<li>Fast forwarding</li>
<li>Normal forwarding</li>
</ol>
<h4 id="Method-resolution"><a href="#Method-resolution" class="headerlink" title="Method resolution"></a>Method resolution</h4><p>Method resolution提供了两个方法，一个是<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>，另一个是<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>。从名字可以看出，一个是用于实例方法，一个用于类方法。都是一样的，我们以上面的[person doSomething]为类，来重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>来保证运行不崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void testMethod(id obj, SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;testMethod防止程序崩溃&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    if (sel == @selector(doSomething)) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)testMethod, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序之后，会发现没有抛出异常，而是打印出了<code>testMethod防止程序崩溃</code>的信息。</p>
<h4 id="Fast-forwarding"><a href="#Fast-forwarding" class="headerlink" title="Fast forwarding"></a>Fast forwarding</h4><p>在使用之前，，我们先给测试类新加一个方法，来创造下测试条件，在头文件中加上下面这句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)hasPrefix:(NSString *)str;</div></pre></td></tr></table></figure>
<p>实现文件里什么都不写，运行之后会发现直接报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;-[MessageSendTest hasPrefix:]: unrecognized selector sent to instance 0x60800000ccf0&apos;</div></pre></td></tr></table></figure>
<p>好了，我们看下如何使用Fast forwarding来保证异常不会发生。我们在测试类中重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    if (aSelector == @selector(hasPrefix:)) &#123;</div><div class="line">        return [NSString string];</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，在该方法中，我们让如果请求的是<code>hasPrefix:</code>，直接返回<code>[NSString string]</code>，将这个消息转发给了NSString对象，我们知道，<code>hasPrefix:</code>是NSString的系统方法，肯定有实现的，所以再次运行程序之后，没有崩溃。</p>
<h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>Normal forwarding一般是最后救命的稻草了。这些可以在<code>-forwardInvocation:</code>中实现，我们还是用上面的例子。</p>
<p>我们先定义一个全局的NSString变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString _string = [NSString string];</div></pre></td></tr></table></figure>
<p>下面是关键实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    SEL sel = anInvocation.selector;</div><div class="line"></div><div class="line">    if ([_string respondsToSelector:sel]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_string];</div><div class="line">    &#125;else &#123;</div><div class="line">        [self doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [_string methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码也是比较好理解的，调用一个方法，首先会走<code>methodSignatureForSelector</code>这个方法，如果发现方法签名是nil，我们加了个判断，如果是nil，则走NSString实例的方法签名。</p>
<p>重签名之后，会走<code>forwardInvocation</code>来进行分发，我们这里增加了一个判断，如果在NSString中找到该SEL，那么就直接在新的对象上执行该SEL，否则执行<code>doesNotRecognizeSelector</code>方法。这样就可以完全避免<code>unrecognized selector sent to instance</code>崩溃问题。</p>
<p>另外，如果关注过JSPatch的同学，可以看到JSPatch作者解决参数获取的问题时，就用了这个技术，详情可以查看Bang的博客, 在文末那里可以找到。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p>
<p><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/03/load和initialize的特殊之处/" class="prev">PREV</a><a href="/2016/07/21/dispatch-apply总结/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'hyyyblog';
var disqus_identifier = '2016/09/05/初识Runtime/';
var disqus_title = '初识Runtime';
var disqus_url = 'http://yoursite.com/2016/09/05/初识Runtime/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//hyyyblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Hyyy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>