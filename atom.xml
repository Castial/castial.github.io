<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyyy的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-18T07:52:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hyyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS小结之多线程</title>
    <link href="http://yoursite.com/2017/06/18/iOS%E5%B0%8F%E7%BB%93%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/18/iOS小结之多线程/</id>
    <published>2017-06-18T07:49:32.000Z</published>
    <updated>2017-06-18T07:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第三篇，来总结总结iOS中多线程操作。</p>
</blockquote>
<h3 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h3><p>对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。</p>
<p>谈细节之前里，我们得说下有关多线程的几个概念。</p>
<h4 id="串行和并发"><a href="#串行和并发" class="headerlink" title="串行和并发"></a>串行和并发</h4><p>串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如<code>NSDictionary</code>就是线程安全的，可以在多线程中使用它，不会出现问题，而<code>NSMutableDictionary</code>是线程不安全的，所以使用<code>NSMutableDictionary</code>的时候应该保证每次只能有一个线程访问它。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。</p>
<a id="more"></a>
<h3 id="iOS多线程方案"><a href="#iOS多线程方案" class="headerlink" title="iOS多线程方案"></a>iOS多线程方案</h3><h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h4><p><code>Pthreads</code>是基于C语言的通用多线程API，在日常开发中基本上用不到，并且目前在Swift中貌似并不能直接调用这套API。所以这种方案只提一下，不过多介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p><code>NSThread</code>是一套比较轻量级的多线程方案，可以直观地控制线程对象，一个<code>NSThread</code>代表一条线程，但是需要自己管理线程的生命周期，线程同步等问题，</p>
<p>创建thread目前所了解到的有4种方式，其中类方法两个，实例方法两个。类方法创建线程后会自动启动该线程，而实例方法只会创建线程，启动需要手动去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 第一种类方法</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadHandler) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">- (void)threadHandler &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二个类方法</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;block current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>下面是两种实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 第一个实例方法</div><div class="line">NSThread *thread1 = [[NSThread alloc] initWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[thread1 start];</div><div class="line"></div><div class="line">// 第二个实例方法</div><div class="line">NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(threadHandler:) object:@&#123;@&quot;title&quot; : @&quot;2123&quot;&#125;];</div><div class="line">[thread2 start];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的之外，<code>NSThread</code>还提供了一个<code>NSObject+NSThreadPerformAdditions</code>，用于在NSObject中执行线程调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在主线程执行一个任务，后者区别在于可以指定在哪种Runloop模式下运行，有关Runloop可以参考上篇文章。</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在指定的线程中执行一个任务。</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在后台隐形创建线程，执行一个任务</div><div class="line">[self performSelectorInBackground:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125;];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，NSThread还提供了设置线程优先级功能，叫做NSQualityOfService，一共分为一下几种：</p>
<ul>
<li>NSQualityOfServiceUserInteractive。用于用户交互，最高优先级</li>
<li>NSQualityOfServiceUserInitiated。用于执行需要立即返回的的任务，次高优先级</li>
<li>NSQualityOfServiceDefault。线程默认优先级</li>
<li>NSQualityOfServiceUtility。用于执行普通任务，普通优先级</li>
<li>NSQualityOfServiceBackground。最低优先级，用于执行不重要的任务</li>
</ul>
<p>还有其他一些线程操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 线程休眠，休眠线程会阻塞当前线程</div><div class="line">[NSThread sleepForTimeInterval:5.0];</div><div class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:5.0]];</div><div class="line"></div><div class="line">// 线程取消，调用此方法并不会马上停止线程运行，只仅仅是线程状态记录</div><div class="line">[thread cancel];</div><div class="line"></div><div class="line">// 线程停止，执行此方法会立即终止主线程外其他所有线程，所以调用请慎用。</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">// 获取当前线程</div><div class="line">[NSThread currentThread];</div><div class="line"></div><div class="line">// 获取主线程</div><div class="line">[NSThread mainThread];</div><div class="line"></div><div class="line">// 停止当前线程的Runloop</div><div class="line">CFRunLoopStop(CFRunLoopGetCurrent());</div></pre></td></tr></table></figure>
<p>如果有多个线程共享一块资源，对资源进行操作时候，还涉及到线程同步问题，一段时间只允许一条线程来操作资源，不然会引起冲突，iOS实现线程加锁有NSLock和@synchronized两种方式。其用法也比较简单，在这里就不过多介绍。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD全称是Grand Central Dispatch，是为了给iOS和mac的多核硬件上执行支持，其实现方式是一套底层C API。通过GCD，开发者不用和线程打交道，只需要使用一个Block就可以实现多线程操作。GCD提供的API简单易懂，提供了一个易于使用的并发模型，对于开发者来说，并不需要关心多线程的并发问题，GCD底层自动处理这些逻辑。</p>
<p>出了这些之外，GCD其实还可以根据当前的系统负载来增减线程数量，我们都知道线程的创建切换都是需要代价的，是有消耗的，所以使用GCD还可以增加效率，提供更高的性能。</p>
<p>GCD操作是需要通过队列来操作的，有三种队列可以使用。</p>
<ul>
<li>串行队列(Serial)。串行队列的特点是以先进先出的顺序来执行的，队列内的东西是以顺序执行的，但是多个串行队列直接是以并发执行的。</li>
<li>并行队列(Concurrent)。并行队列和串行队列相反，可以同时执行多个任务，但是多个任务之间，仍然是以先进先出的顺序执行的，区别在于，并行队列会跟酒系统负载，尽可能多地创建线程去执行这些任务。但是哪个任务先执行完毕是不确定的。</li>
<li>主线程队列(Main dispatch queue)。实际上，主线程队列是一个和主线程相关的串行队列。这个队列中的任务每次只会有一个执行。可以保证所有的任务都会在主线程执行，所以涉及到UI操作的需要使用这个队列来完成。</li>
</ul>
<p>创建一个串行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(@&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">// 这种也可以，NULL默认就是串行</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div></pre></td></tr></table></figure>
<p>创建一个并行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;coml.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 也可以用下面这种</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div></pre></td></tr></table></figure>
<p>主线程队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>GCD往队列里添加任务有两种方式，一种是异步，一种是同步。</p>
<ul>
<li>异步(dispatch_async)。是一个异步添加操作，dispatch_async会立即返回；</li>
<li>同步(dispatch_sync)。是一个同步添加操作，dispatch_sync区别是会阻塞当前线程，会等待block里的任务执行完毕之后才会返回。</li>
</ul>
<p>dispatch_async添加任务，会立即返回，所以下面的打印顺序不确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果：</div><div class="line">ThreadTest[17614:2597588] ========2</div><div class="line">ThreadTest[17614:2597588] ========1</div></pre></td></tr></table></figure>
<p>如果是dispatch_sync，由于是同步，所以打印结果是有顺序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果</div><div class="line">ThreadTest[17599:2595130] ========1</div><div class="line">ThreadTest[17599:2595130] ========2</div></pre></td></tr></table></figure>
<p>但是dispatch_sync尽量少用，使用不当会造成死锁。比如下面的代码就会造成死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    NSLog(@&quot;这里死锁了&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是，死锁并不是这里使用了主线程造成的，不用主线程，照样可以造成死锁。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.hyyy.thread&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">NSLog(@&quot;========1&quot;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_sync(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;========3&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种也会发生死锁，所以不要听信什么主线程的问题，不是主线程照样可以发生死锁。死锁真的发生的原因是dispatch_sync添加进的queue队列是当前queue队列。在主线程死锁的那段代码中，我们调用的dispatch_sync是添加在主线程queue中，使主线程堵塞，而我们的Block又需要主线程queue来执行，所以相互等待，造成死锁了。</p>
<p>但是为什么添加队列换成并行队列就不会有问题呢？还是上面的概念，对于并行队列中任务的执行，其执行开始和结束并不取决于上一个任务的结束时间，只仅仅取决于任务的耗时。即便任务是以同步的方式添加进去，但是在并行队列中也会在另外一个线程去跑这个任务。</p>
<p>这里还需要提一个题外话，在并发队列里的Block何时执行，开发者是不用知道的，完全取决于GCD，但是我们也是有方法可以让其按照顺序执行。</p>
<p>GCD的使用场景有很多，我们一个一个举例来说明。</p>
<p><strong>后台下载显示图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    NSURL * url = [NSURL URLWithString:@&quot;http://www.yourimage.com&quot;];</div><div class="line">    NSError * error;</div><div class="line">    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    if (data != nil) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.imageView.image = [UIImage imageWithData:data];</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;error when download:%@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个经典的使用场景，有时候我们需要后台处理一个任务，然后在主线程进行UI渲染，可以这么干。</p>
<p><strong>单例模式</strong></p>
<p>单例模式是设计模式中最简单的一种了，它的目的是创建的类对象在系统中是唯一的，一个类只有一个实例，节约系统资源。一般我们创建一个单例会这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//Singleton.h</div><div class="line">@interface Singleton : NSObject</div><div class="line">+ (Singleton *)sharedInstance;</div><div class="line">@end</div><div class="line"></div><div class="line">//Singleton.m</div><div class="line">@implementation Singleton</div><div class="line">static Singleton * sharedSingleton = nil;</div><div class="line">+ (Singleton *) sharedInstance &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedSingleton;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里我们用到了dispatch_once_t，对于给定的token来说，Block里的代码必定会执行，并且会仅执行一次。最重要的一点是，这里的操作是线程安全的，十分高效。但是需要注意的是token这个东西是应该声明称static或者global，这样来保证每次传进去的token是相同的。</p>
<p><strong>dispatch_after延后执行</strong></p>
<p>dispatch_after可以做到使一块代码延时执行，但是需要注意的是，这里的延时是有歧义的，dispatch_after做到的仅是延时把这一项任务提交到队列中去，至于什么时候执行，是和GCD内部处理逻辑有关的。</p>
<p>比如我想0.5秒之后发送一条通知，可以这么干。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:HY_AFTER_NOTIFICATION object:nil];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>dispatch_apply快速迭代</strong></p>
<p>dispatch_apply和遍历的效果差不多，其作用是把指定次数的block添加到queue中，好处是dispatch_apply可以不用管理线程方面的问题，GCD会自动处理并发现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    NSString *str = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %@&quot;, str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>Dispatch_groups</strong></p>
<p>Dispatch_groups作用是用来监视多个并行任务的执行，来进行线程同步的。在多个任务执行完毕后，想要执行结束处理，就可以使用Dispatch_groups来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue2, ^&#123;</div><div class="line">    NSLog(@&quot;========3&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">========3</div><div class="line">========1</div><div class="line">========2</div><div class="line">========end</div></pre></td></tr></table></figure>
<p>可以看到，上面三个任务执行完毕之后，才会走最后一个block回调，我们可以利用这种模式做很多事。但是千万不要像下面这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========1&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========2&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这么写会有问题，dispatch_group_async里执行的是异步任务，而dispatch_group_notify并不会等待异步任务完成，如果真的这么做，那就需要dispatch_group_enter和dispatch_group_leave来进行约束，也是我用的比较多的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的事，dispatch_group_enter和dispatch_group_leave总是对应出现的，类似于引用计数原理，有加有减。</p>
<p><strong>dispatch_barrier并发问题</strong></p>
<p>在并行队列里，有时候我们需要每次只单独执行一个任务，也就是当有个任务执行的时候，不允许其他任务执行，类似于多线程读写问题，这时候Dispatch Barrier就发挥了作用。</p>
<p>Dispatch Barrier可以保证提交的block是指定队列里某个时段唯一执行的一个，下面用一个示例来演示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">//等待前面的都完成，在执行barrier后面的</div><div class="line">dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;写数据&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:1];</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:1.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在进行写数据的时候，因为使用了Dispatch Barrier，不会发生读数据的操作，所以保证了每次写入数据只会有一个任务在执行。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>相比于GCD，NSOperation显得并没有那么流行，但是称得上是先进的面向对象的多线程解决办法。同样，对于开发者来讲，我们根本不用考虑线程的生命周期、同步，加锁等晦涩问题。</p>
<p>使用NSOperation有三种方式，NSInvocationOperation、NSBlockOperation和自定义子类继承NSOperation。</p>
<p><strong>NSInvocationOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>NSInvocationOperation默认情况下，并不会新开一个线程去跑，而是在当前线程去执行任务，可以将NSInvocationOperation放到NSOperationQueue中，即可实现异步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000077140&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x60800006e440&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p><strong>NSBlockOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>和NSInvocationOperation一样，默认NSBlockOperation只会在当前线程上执行。如果需要新开线程操作，可以添加到NSOperationQueue中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60800007d7c0&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000767c0&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>另外，可以使用addExecutionBlock添加额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000771c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000264280&gt;&#123;number = 5, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000260980&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000002640c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用addExecutionBlock会在新线程中去执行。但是并不是每次都会创建，我们可以试下多创建几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000071bc0&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000072040&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000000706c0&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>所以，如果NSBlockOperation封装的操作数大于1的时候,才会执行异步操作.不然也是在当前线程下执行的。</p>
<p>另外，NSOperation可以取消的，这个算是一大特色了，也是NSOperation的使用场景之一了。NSOperation有三种状态，isReady -&gt; isExecuting -&gt; isFinish， 如果在Ready的状态中对NSOperation进行取消，NSOperation会进入Finish状态。但是Operation已经开始执行了，就会一直运行到结束，或者由我们进行取消。也就是说Operation已经在executing状态，我们调用cancle方法系统不会中止线程的，这需要我们在任务过程中检测取消事件，并中止线程的执行，还要注意一点我们要释放内存或资源。</p>
<p>需要注意的是，调用cancel并不会退出线程，需要自行终止线程的运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![operation isCancelled]) &#123;</div><div class="line">    [operation cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有，NSOpertion可以设置优先级，从而改变其执行顺序，我们举个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1后执行&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2先执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 addDependency:operation2];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2先执行</div><div class="line">operation1后执行</div></pre></td></tr></table></figure>
<p>但是不能互相添加依赖，不然就死锁了，两个永远都不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[operation1 addDependency:operation2];</div><div class="line">[operation2 addDependency:operation1];</div></pre></td></tr></table></figure>
<p>有些时候，我们需要监听到任务完成后的回调事件，NSOperation也提供了这个方法，叫CompletionBlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation2 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2执行</div><div class="line">operation1执行</div><div class="line">operation2执行完毕</div><div class="line">operation1执行完毕</div></pre></td></tr></table></figure>
<p>还有自定义NSOperation，由于不是经常能用到，所以就不多做介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS多线程就总结到这里了，不过一般开发中用的GCD比较多，偶尔会用到NSOperation，这两个理解了就够用了，根据需求来定技术方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第三篇，来总结总结iOS中多线程操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多线程概述&quot;&gt;&lt;a href=&quot;#多线程概述&quot; class=&quot;headerlink&quot; title=&quot;多线程概述&quot;&gt;&lt;/a&gt;多线程概述&lt;/h3&gt;&lt;p&gt;对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。&lt;/p&gt;
&lt;p&gt;谈细节之前里，我们得说下有关多线程的几个概念。&lt;/p&gt;
&lt;h4 id=&quot;串行和并发&quot;&gt;&lt;a href=&quot;#串行和并发&quot; class=&quot;headerlink&quot; title=&quot;串行和并发&quot;&gt;&lt;/a&gt;串行和并发&lt;/h4&gt;&lt;p&gt;串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。&lt;/p&gt;
&lt;h4 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h4&gt;&lt;p&gt;同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。&lt;/p&gt;
&lt;h4 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h4&gt;&lt;p&gt;临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。&lt;/p&gt;
&lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。&lt;/p&gt;
&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;p&gt;线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如&lt;code&gt;NSDictionary&lt;/code&gt;就是线程安全的，可以在多线程中使用它，不会出现问题，而&lt;code&gt;NSMutableDictionary&lt;/code&gt;是线程不安全的，所以使用&lt;code&gt;NSMutableDictionary&lt;/code&gt;的时候应该保证每次只能有一个线程访问它。&lt;/p&gt;
&lt;h4 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h4&gt;&lt;p&gt;上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之Runloop</title>
    <link href="http://yoursite.com/2017/06/11/iOS%E5%B0%8F%E7%BB%93%E4%B9%8BRunloop/"/>
    <id>http://yoursite.com/2017/06/11/iOS小结之Runloop/</id>
    <published>2017-06-11T07:34:03.000Z</published>
    <updated>2017-06-11T07:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第二篇，来总结下Runloop的知识。</p>
</blockquote>
<h3 id="Runloop概述"><a href="#Runloop概述" class="headerlink" title="Runloop概述"></a>Runloop概述</h3><p>学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initLoop();</div><div class="line">    do &#123;</div><div class="line">        if(message_hasTask()) &#123;</div><div class="line">            message_execute(get_current_message());</div><div class="line">        &#125;</div><div class="line">    &#125; while (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。</p>
<p>这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。</p>
<a id="more"></a>
<p>在iOS中，提供了两种有关的对象，一种是<code>NSRunLoop</code>，另外一种是<code>CFRunLoopRef</code>。<code>CFRunLoopRef</code>是基于<code>CoreFoundation</code>框架的，提供了纯C函数的API，所以这些API都是线程安全的。我们一般听到的<code>NSRunLoop</code>，是对<code>CFRunLoopRef</code>的封装，加上了面向对象的东西，所以这些API不是安全的。</p>
<p>所以，一般讲解<code>Runloop</code>的文章，其实都是在分析<code>CFRunLoopRef</code>这个东西。<code>CFRunLoopRef</code>的具体实现，苹果也将它开源了出来，可以在引用里看到其链接，这里就不再给出。</p>
<h3 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h3><p>上面可以看出，需要实现一个Runloop模型，是基于线程之上的。所以，Runloop和线程是息息相关的，在iOS系统中，Runloop属于线程的基础架构部分。每个线程，包括程序的主线程，都有与之的Runloop模型。</p>
<p>其实，Runloop和线程的绑定，是保存在一个全局的Dictionary中，线程和Runloop之间是一一对应的。当线程创建后，默认并不会启动Runloop，只有主动获取的时候，Runloop才会被创建，当线程结束后，对应的Runloop也会随之销毁。但是有个例外，就是主线程对应的Runloop默认是启动的。当程序启动的时候，会执行下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">   @autoreleasepool &#123;</div><div class="line">       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，在<code>UIApplicationMain</code>内部帮我们开启了主线程的Runloop，相当于说，主线程的Runloop是默认启动的。这样我们才可以监听触摸事件、页面刷新等等功能。</p>
<h3 id="Runloop结构"><a href="#Runloop结构" class="headerlink" title="Runloop结构"></a>Runloop结构</h3><p>Runloop主要由5个类组成。如下所示：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其关系如下图：</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="Runloop关系图"></p>
<p>一个Runloop包含多个Mode，每个Mode里面又包含多个Source/Timer/Observer。但是，需要注意的是，每次开启Runloop的时候，只会使用其中一个Mode，一般叫做currentMode。有时候实际场景中需要切换Mode，切换的时候，只能先退出Mode，然后再添加上新的Mode。</p>
<h4 id="Source0-和-Source1"><a href="#Source0-和-Source1" class="headerlink" title="Source0 和 Source1"></a>Source0 和 Source1</h4><p><strong>CFRunLoopSourceRef</strong>有两个版本：Source0和Source1，Source的作用是给线程发送异步事件。其中Source0是接收App内部的事件，比如用户点击滑动等事件，App自己负责处理，需要手动来唤醒Runloop，来处理这个事件；Source1是通过内核和其他线程发送消息用的，可以自动唤醒Runloop的线程。</p>
<h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>顾名思义，<strong>CFRunLoopTimerRef</strong>是基于时间来出发的，和NSTimer底层一样。当其加入到Runloop时，Runloop会注册对应的时间点，当时间点到时，Runloop会唤醒执行那个回调。常见的使用场景比如：延迟执行某个方法、CADisplayLink的使用等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</div><div class="line"></div><div class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div></pre></td></tr></table></figure>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p><strong>CFRunLoopObserverRef</strong>是基于观察者模式，和<code>CFRunLoopTimerRef</code>类似，每个Observer都会包含有一个回调，用于监听Runloop的状态变化。可以监听到的状态变化有如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面所介绍的Source、Timer和Observer都可以添加到多个Model当中，但是如果在一个Mode当中添加多个，是不会起效果的，有一种特殊情况，就是当一个Mode里什么都没有，则这个Runloop就会直接退出。</p>
<h3 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h3><p>上面已经说过，Runloop的运行是基于特定的Mode，其数据结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     // Set</div><div class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</div><div class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</div><div class="line">    CFMutableSetRef _modes;           // Set</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意一下，有一个很关键的属性叫<code>CommonModes</code>，每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>在iOS系统中包含了两个Mode，一个是<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>。这两个Mode都已经被注册成了CommonMode，一般App主线程的Runloop默认是<code>NSDefaultRunLoopMode</code>，当UIScrollView滑动的时候，Runloop就会退出，然后切换到<code>UITrackingRunLoopMode</code>。这两个是苹果公开的Mode，当然，还有一些私有Mode，就在这里不阐述了，有兴趣的读者可以Google一下。</p>
<p>出了上面这些，苹果还提供一个操作<code>CommonModes</code>的字符串，可以对所有CommonMode进行操作，叫做<code>kCFRunLoopCommonModes</code>，有些同学容易将这个东西和上面的Mode混淆，其实概念还是不一样的，<code>kCFRunLoopCommonModes</code>并不是一个新的Mode，在App主线程的Runloop中，是一个<code>CommonModes</code>组合，包含<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两种Mode。这里的话在下面NSTimer的应用场景中详细讲下。</p>
<h3 id="Runloop常见应用场景"><a href="#Runloop常见应用场景" class="headerlink" title="Runloop常见应用场景"></a>Runloop常见应用场景</h3><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>AutoreleasePool其实和Runloop是有关系的，有一个经典的面试题是问<code>AutoreleasePool对象是什么时候释放的？</code>，什么答案都有，标准答案应该是AutoreleasePool对象应该是在当前Runloop迭代结束之后释放的。</p>
<p>当App启动之后，iOS会在主线程注册两个Observer，第一个Observer是监听即将进入Runloop的状态，监听到后，来创建AutoreleasePool对象，其优先级也是最高的，要保证创建AutoreleasePool发生在其他所有回调之前；第二个Observer是监听Runloop准备休眠状态，来释放旧的AutoreleasePool对象，并且创建新的AutoreleasePool对象以供使用，另外还需要监听即将退出Runloop的状态，优先级是最低的，以此来保证释放操作在其他所有回调之后。</p>
<p>所以，如果以后有人再问你<code>AutoreleasePool对象是什么时候释放的？</code>，一定要说这和Runloop有关系，当Runloop准备休眠的时候，会释放旧的AutoreleasePool对象，创建新的AutoreleasePool对象，当Runloop即将退出的时候，会释放掉相关所有的AutoreleasePool对象。</p>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>NSTimer在时间点的触发，是基于Runloop运行的，使用NSTimer之前，都需要将其注册到Runloop上。其实NSTimer就是CFRunLoopTimerRef，一个NSTimer注册好之后，Runloop会自动在时间节点注册好事件。但是Runloop为了节省资源，并不会在非常准确的时间节点调用定时器。为此，NSTimer专门提供了一个tolerance属性，来设置宽容度，标记当时间节点到来之后，容许有多少误差可以触发回调。如果错过了某个时间节点，就只能等下一个时间节点的到来。</p>
<p>回到之前Mode的话题，当UISCrollView进行滚动的时候，NSTimer就无法正常工作，停止滑动又回恢复正常。这个原因是，添加到Runloop的NSTimer默认是以<code>NSDefaultRunLoopMode</code>模式在工作，当UIScrollView进行滑动的时候，Runloop会退出，然后切换到<code>UITrackingRunLoopMode</code>模式。由于NSTimer不是在这个模式下运行的，所以不会触发定时任务，无法工作。</p>
<p>要解决这个问题，我们就需要将NSTimer在<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两个模式下工作，在UIScrollView滑动的时候也可以进行触发定时任务。所以，我们需要使用到<code>kCFRunLoopCommonModes</code>来完成任务。一般使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h4 id="事件响应和手势识别"><a href="#事件响应和手势识别" class="headerlink" title="事件响应和手势识别"></a>事件响应和手势识别</h4><p>事件响应其实和Runloop也是有关系的，为此，苹果专门注册了一个Source1用来接收系统事件。当手机的硬件发生感应，比如触摸、锁屏和摇晃，苹果注册的这个Source1都会收到回调，然后会将事件进行应用内部分发。</p>
<p>然后，App内主线程的Runloop会触发Source0事件，Source0收到回调进行下一步操作。</p>
<p>不同于事件响应，对于手势识别，收到苹果Source1对应用内部分发事件后，首先先将所有的手势回调打断，将所对应的UIGestureRecognizer事件标记为待处理，然后苹果会注册一个Observer来监听Runloop即将进入休眠的状态，然后在Observer回调里执行GestureRecognizer的回调。</p>
<h4 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h4><p>UI更新也和Runloop有关，当在操作UI时，改变了UI的大小、层次等，这个 UIView/CALayer就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个Observer来监听Runloop即将进入休眠和即将退出的状态，然后在其Observer回调里遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD底层也和Runloop有关，当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取得这个block，并在回调里执行这个block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>PerformSelecter其实是创建了一个Timer，然后添加到当前的线程中。如果当前线程没有Runloop，这个方法则走不通的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</div><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>另外，还有AFNetworking2.0、NSURLConnection的使用其实都和Runloop有关，AFNetworking2.0希望能在后台线程接收到Delegate回调，单独创建了一条线程，并在这条这个线程中启动了Runloop。但是AFNetworking换成基于<code>NSURLSession</code>之后，并没有看到相关Runloop代码。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有关Runloop的东西其实还有很多，这里只是站在大神的肩膀上，总结下基本的Runloop知识，希望能帮到需要的同学！</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
</li>
<li><p><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第二篇，来总结下Runloop的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Runloop概述&quot;&gt;&lt;a href=&quot;#Runloop概述&quot; class=&quot;headerlink&quot; title=&quot;Runloop概述&quot;&gt;&lt;/a&gt;Runloop概述&lt;/h3&gt;&lt;p&gt;学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function loop() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    initLoop();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if(message_hasTask()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            message_execute(get_current_message());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while (message != quit);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。&lt;/p&gt;
&lt;p&gt;这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之copy属性</title>
    <link href="http://yoursite.com/2017/06/05/iOS%E5%B0%8F%E7%BB%93%E4%B9%8Bcopy%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/05/iOS小结之copy属性/</id>
    <published>2017-06-05T10:21:19.000Z</published>
    <updated>2017-06-11T07:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。</p>
</blockquote>
<p>小结第一篇，来总结一下iOS开发中有关copy的知识点。</p>
<h3 id="iOS中，深拷贝和浅拷贝有什么不同？"><a href="#iOS中，深拷贝和浅拷贝有什么不同？" class="headerlink" title="iOS中，深拷贝和浅拷贝有什么不同？"></a>iOS中，深拷贝和浅拷贝有什么不同？</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p>
<h4 id="非集合类对象的copy和mutableCopy"><a href="#非集合类对象的copy和mutableCopy" class="headerlink" title="非集合类对象的copy和mutableCopy"></a>非集合类对象的copy和mutableCopy</h4><p>我们对一个NSString属性进行copy和mutableCopy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;abc&quot;;</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x1022fe078, 0x7fff5d901a48</div><div class="line">stringCopy: 0x1022fe078, 0x7fff5d901a40</div><div class="line">stringMCopy: 0x608000260240, 0x7fff5d901a38</div></pre></td></tr></table></figure>
<p>可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。</p>
<a id="more"></a>
<p>接下来，我们对NSMutableString进行copy和mutableCopy.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，我们可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x608000264680, 0x7fff5526aa48</div><div class="line">stringCopy: 0xa000000006362613, 0x7fff5526aa40</div><div class="line">stringMCopy: 0x608000264940, 0x7fff5526aa38</div></pre></td></tr></table></figure>
<p>对NSMutableString进行copy操作，其内存地址和指针地址都发生了变化，所以操作是深拷贝，和上面有所不同；进行mutableCopy操作，其内存地址和指针地址也都发生了变化，所以也是深拷贝。</p>
<blockquote>
<p>以上，我们可以得出，在非集合类对象中，对不可变对象进行copy操作，只仅仅是指针复制，进行mutableCopy操作，是内容复制。</p>
<p>对可变对象进行copy和mutableCopy操作，都是内容复制。</p>
</blockquote>
<h4 id="集合类对象的copy和mutableCopy"><a href="#集合类对象的copy和mutableCopy" class="headerlink" title="集合类对象的copy和mutableCopy"></a>集合类对象的copy和mutableCopy</h4><p>我们以NSArray为例，对其进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSArray *array = @[element_01, element_02, element_03];</div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x600000245910, 0x7fff51367a10; array.firstObject: 0x10e898088</div><div class="line">arrayCopy: 0x600000245910, 0x7fff51367a08; arrayCopy.firstObject: 0x10e898088</div><div class="line">arrayMCopy: 0x600000245670, 0x7fff51367a00; arrayMCopy.firstObject: 0x10e898088</div></pre></td></tr></table></figure>
<p>可以发现，规律和非集合类的很像，对NSArray进行copy操作的时候，数组的内存地址没有发生变化，但是进行mutableCopy操作时，其内存地址发生了变化，结论跟非集合类的差不多。</p>
<p>但是，这里的深拷贝和非集合类的深拷贝还是不太一样的，上面我们打印出了数组的第一个元素的内存地址，可以发现，进行mutableCopy操作时，虽然数组内存地址发生了变化，但是数组元素的内存地址并没有发生变化。</p>
<p>这个属于一个特例，我们称它为<strong>单层深复制</strong>。并不是理论上的完全深复制。</p>
<p>接下来，我们以NSMutableArray为例，进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:@[element_01, element_02, element_03]];</div><div class="line"></div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x6000000460c0, 0x7fff516d3a10; array.firstObject: 0x10e52c088</div><div class="line">arrayCopy: 0x600000046420, 0x7fff516d3a08; arrayCopy.firstObject: 0x10e52c088</div><div class="line">arrayMCopy: 0x600000046000, 0x7fff516d3a00; arrayMCopy.firstObject: 0x10e52c088</div></pre></td></tr></table></figure>
<p>可以看出，对NSMutableArray进行copy和mutableCopy操作，其内存地址都发生了变化，但是，对于数组中的元素，不管是进行的哪种操作，内存地址始终都没有发生变化，所以属于单层深拷贝。</p>
<blockquote>
<p>所以，我们可以得出，对于不可变的集合类对象进行copy操作，只是改变了指针，其内存地址并没有发生变化；进行mutableCopy操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。</p>
<p>对于可变集合类对象，不管是进行copy操作还是mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p>
</blockquote>
<h3 id="为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"><a href="#为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？" class="headerlink" title="为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"></a>为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？</h3><p>这种场景，在定义model时出现最多，首先我们先来看看用copy和strong有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *strStrong;</div><div class="line">@property (nonatomic, copy) NSString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strStrong = string;</div><div class="line">self.strCopy = string;</div><div class="line">NSLog(@&quot;旧strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;旧strCopy: %@&quot;, self.strCopy);</div><div class="line"></div><div class="line">[string appendFormat:@&quot;def&quot;];</div><div class="line">NSLog(@&quot;新strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;新strCopy: %@&quot;, self.strCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">旧strStrong: abc</div><div class="line">旧strCopy: abc</div><div class="line">新strStrong: abcdef</div><div class="line">新strCopy: abc</div></pre></td></tr></table></figure>
<p>可以发现，当将一个可变对象分别赋值给两个使用不同修饰词的属性后，改变可变对象的内容，使用strong修饰的会跟随着改变，但使用copy修饰的没有改变内容。</p>
<p>知道了strong和copy修饰的区别之后，我们来看为什么要用copy？因为属性需要有封装性，当赋值之后，如果改变其值，会打破本有的封装，所以，在日常大部分开发工作中，我们需要使用copy来修饰NSString等。</p>
<p>那么，是不是NSMutableString等这些可变对象是不是也需要copy来修饰呢？答案是千万不要这么干，我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSMutableString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strCopy = string;</div><div class="line">[self.strCopy appendString:@&quot;def&quot;];</div></pre></td></tr></table></figure>
<p>运行上面代码，就会发现，在运行到最后一句的时候会崩溃，因为copy是复制出一个不可变的对象，在不可变对象上运行可变对象的方法，就会找不到执行方法，报下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa000000006362613&apos;</div></pre></td></tr></table></figure>
<h3 id="自定义对象实现copy"><a href="#自定义对象实现copy" class="headerlink" title="自定义对象实现copy"></a>自定义对象实现copy</h3><p>有时候，我们需要实现自定义的对象进行copy操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div></pre></td></tr></table></figure>
<p>但是，一运行我们发现直接崩溃了，报了一下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[CopyModel copyWithZone:]: unrecognized selector sent to instance 0x608000221c60&apos;</div></pre></td></tr></table></figure>
<p>可以看出，自定义对象实现copy操作，需要重写<code>copyWithZone</code>方法，我们修改下代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* CopyModel.m **********************/</div><div class="line">@implementation CopyModel</div><div class="line"></div><div class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    CopyModel *copyModel = [[CopyModel allocWithZone:zone] init];</div><div class="line">    copyModel.title = self.title;</div><div class="line">    copyModel.name = self.name;</div><div class="line">    return copyModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div><div class="line">NSLog(@&quot;model: %p, %p&quot;, model, &amp;model);</div><div class="line">NSLog(@&quot;modelCopy: %p, %p&quot;, modelCopy, &amp;modelCopy);</div></pre></td></tr></table></figure>
<p>执行之后，可以发现并没有报错，并且copy也成功了。控制台打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model: 0x608000037660, 0x7fff5bd62a48</div><div class="line">modelCopy: 0x60800003afa0, 0x7fff5bd62a40</div></pre></td></tr></table></figure>
<p>说明我们自定义对象copy成功了!</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是当前遇到的有关copy问题的总结，应该还算挺全的，希望能帮助到需要的同学！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结第一篇，来总结一下iOS开发中有关copy的知识点。&lt;/p&gt;
&lt;h3 id=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;a href=&quot;#iOS中，深拷贝和浅拷贝有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;/a&gt;iOS中，深拷贝和浅拷贝有什么不同？&lt;/h3&gt;&lt;h4 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h4&gt;&lt;p&gt;所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。&lt;/p&gt;
&lt;h4 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝&quot;&gt;&lt;/a&gt;深拷贝&lt;/h4&gt;&lt;p&gt;所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。&lt;/p&gt;
&lt;h4 id=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;a href=&quot;#非集合类对象的copy和mutableCopy&quot; class=&quot;headerlink&quot; title=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;/a&gt;非集合类对象的copy和mutableCopy&lt;/h4&gt;&lt;p&gt;我们对一个NSString属性进行copy和mutableCopy。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString *string = @&amp;quot;abc&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *stringCopy = [string copy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSMutableString *stringMCopy = [string mutableCopy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;string: %p, %p&amp;quot;, string, &amp;amp;string);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringCopy: %p, %p&amp;quot;, stringCopy, &amp;amp;stringCopy);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringMCopy: %p, %p&amp;quot;, stringMCopy, &amp;amp;stringMCopy);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后，可以发现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;string: 0x1022fe078, 0x7fff5d901a48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringCopy: 0x1022fe078, 0x7fff5d901a40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringMCopy: 0x608000260240, 0x7fff5d901a38&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中遍历的总结</title>
    <link href="http://yoursite.com/2017/04/20/iOS%E4%B8%AD%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/20/iOS中遍历的总结/</id>
    <published>2017-04-20T13:15:11.000Z</published>
    <updated>2017-06-11T07:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历的种类"><a href="#遍历的种类" class="headerlink" title="遍历的种类"></a>遍历的种类</h3><p>在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：</p>
<h4 id="经典for循环"><a href="#经典for循环" class="headerlink" title="经典for循环"></a>经典for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (int i = 0; i &lt; iosArray.count; i++) &#123;</div><div class="line">    //处理数组中数据</div><div class="line">    NSLog(@&quot;%@&quot;, iosArray[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSEnumerator遍历"><a href="#NSEnumerator遍历" class="headerlink" title="NSEnumerator遍历"></a>NSEnumerator遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历</div><div class="line">// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历</div><div class="line"></div><div class="line">id object;</div><div class="line"></div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    //处理枚举器中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="for-in快速遍历"><a href="#for-in快速遍历" class="headerlink" title="for-in快速遍历"></a>for-in快速遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="EnumeratorBlock遍历"><a href="#EnumeratorBlock遍历" class="headerlink" title="EnumeratorBlock遍历"></a>EnumeratorBlock遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;    // 跳出遍历</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>另外，EnumeratorBlock还支持反向遍历，并发遍历，并发遍历可以使用多核的优化，充分利用系统的资源。</p>
<h4 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="并发遍历"><a href="#并发遍历" class="headerlink" title="并发遍历"></a>并发遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSMutableArray *iosMutableArray = [NSMutableArray arrayWithArray:iosArray];</div><div class="line">[iosMutableArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    obj = [NSString stringWithFormat:@&quot;_%@&quot;, obj];</div><div class="line">    [iosMutableArray replaceObjectAtIndex:idx withObject:obj];</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line"></div><div class="line">    if ([obj isEqualToString:@&quot;_I&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="dispatch-apply遍历"><a href="#dispatch-apply遍历" class="headerlink" title="dispatch_apply遍历"></a>dispatch_apply遍历</h4><p>dispatch_apply类似于for循环，这里需要注意的是，dispatch_apple是同步调用，调用完毕返回结果，并且由于是GCD实现，所以可以使用并发队列或者是串行队列。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL); // 串行队列</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    Enumerate *enumerate = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %ld&quot;, enumerate.number);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="遍历的注意事项"><a href="#遍历的注意事项" class="headerlink" title="遍历的注意事项"></a>遍历的注意事项</h3><h4 id="for循环中不要修改数组"><a href="#for循环中不要修改数组" class="headerlink" title="for循环中不要修改数组"></a>for循环中不要修改数组</h4><p>遍历过程中是不能随便删除遍历的元素的，如果需要删除元素，可以先复制一份出来，比如如下的代码会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    if([@&quot;e&quot; isEqualTo:obj]) &#123;</div><div class="line">        [iosArray removeObject:obj];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是使用enumerateBlock可以在block内部做removeObject操作，原因应该是和Block的特性有关，<strong>在Block中会保存变量的值，而不会随变量的值的改变而改变</strong>。</p>
<h4 id="遍历的速率"><a href="#遍历的速率" class="headerlink" title="遍历的速率"></a>遍历的速率</h4><p>当数组容量很大的时候，如果只是进行数组遍历的话，使用for-in是最快速的，其次是并发遍历，这个很多人都以为enumerateBlock是最快的。</p>
<h3 id="遍历实践tips"><a href="#遍历实践tips" class="headerlink" title="遍历实践tips"></a>遍历实践tips</h3><h4 id="数组分组"><a href="#数组分组" class="headerlink" title="数组分组"></a>数组分组</h4><p>在开发中，有时需要对数组进行某种情况的分组，比如，一个拥有很多消息模型的数组，我们需要根据消息的创建月份进行分组，那么可以使用下面的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *set=[NSMutableSet set];</div><div class="line">NSArray *array = @[message1, message2, message3, message4, message5, message6, message7];</div><div class="line">__block NSArray *tempDataArray = [NSArray arrayWithArray:array];</div><div class="line">[tempDataArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    [set addObject:obj.month];//利用set不重复的特性,得到有多少组,根据数组中消息的月份属性</div><div class="line">&#125;];</div><div class="line">[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) &#123;//遍历set数组</div><div class="line">    NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF.month = %@&quot;, obj];//创建谓词筛选器</div><div class="line">    NSArray *group = [tempDataArray filteredArrayUsingPredicate:predicate];//用数组的过滤方法得到新的数组,在添加的最终的数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h4><p>倒序遍历也很常见，可以使用上面的反向遍历来实现。</p>
<h4 id="set排序"><a href="#set排序" class="headerlink" title="set排序"></a>set排序</h4><p>这个和Emunerate其实没有关系，但是也很实用，我们知道set是无序的，但是有时需要实现有顺序的set，可以使用下面来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//由于set无序，现将set转换成nsarray</div><div class="line">NSArray *sortDescriptor = @[[[NSSortDescriptor alloc] initWithKey:@&quot;self&quot; ascending:NO]];</div><div class="line">NSArray *sortSetArray = [set sortedArrayUsingDescriptors:sortDescriptor];</div></pre></td></tr></table></figure>
<p>其实原理是将set转化成array来实现的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遍历在我们日常开发中十分常见，根据应用场景，选择合适的遍历方法才是我们需要关系的。这篇文章总结了下遍历的种类和注意事项，希望能帮助到有需要的同学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;遍历的种类&quot;&gt;&lt;a href=&quot;#遍历的种类&quot; class=&quot;headerlink&quot; title=&quot;遍历的种类&quot;&gt;&lt;/a&gt;遍历的种类&lt;/h3&gt;&lt;p&gt;在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：&lt;/p&gt;
&lt;h4 id=&quot;经典for循环&quot;&gt;&lt;a href=&quot;#经典for循环&quot; class=&quot;headerlink&quot; title=&quot;经典for循环&quot;&gt;&lt;/a&gt;经典for循环&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; iosArray.count; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理数组中数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, iosArray[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSEnumerator遍历&quot;&gt;&lt;a href=&quot;#NSEnumerator遍历&quot; class=&quot;headerlink&quot; title=&quot;NSEnumerator遍历&quot;&gt;&lt;/a&gt;NSEnumerator遍历&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;id object;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;while ((object = [enumerator nextObject]) != nil) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理枚举器中的数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, object);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议及推送服务</title>
    <link href="http://yoursite.com/2017/04/02/MQTT%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/04/02/MQTT协议及推送服务/</id>
    <published>2017-04-02T13:31:07.000Z</published>
    <updated>2017-06-11T07:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h3><p>MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。</p>
<h4 id="MQTT特性"><a href="#MQTT特性" class="headerlink" title="MQTT特性"></a>MQTT特性</h4><p>MQTT具有如下特性：</p>
<ul>
<li>使用发布／订阅消息模式，提供一对多消息发布；</li>
<li>对负载内容屏蔽的消息传输；</li>
<li><p>使用TCP/IP进行网络连接；</p>
<p>  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。</p>
</li>
<li><p>具有三种消息发布服务质量选项；</p>
<ol>
<li>“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；</li>
<li>“至少一次”，可以确保消息收到，但消息可能会重复；</li>
<li>“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。</li>
</ol>
</li>
<li><p>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</p>
<p>  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。</p>
</li>
<li><p>通知有关各方客户端异常中断的机制。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="MQTT协议实现方式"><a href="#MQTT协议实现方式" class="headerlink" title="MQTT协议实现方式"></a>MQTT协议实现方式</h4><p><img src="https://itbilu.com/upload/2016/1/9/14523188625918865.png" alt="image"></p>
<p>在MQTT协议中有三种身份：</p>
<ul>
<li>发布者(Publish)。发布者其实是客户端，可以进行发布消息；<ul>
<li>代理(Broker)。代理指的是服务器，比较有名的是eqmtt，当前，你也可以用其他成熟的框架去搭建MQTT服务；</li>
<li>订阅者(Subscribe)。一般指的是客户端，不过，发布者同时也可以是订阅者。</li>
</ul>
</li>
</ul>
<h4 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h4><p>一般来说，客户端可以实现一下功能：</p>
<ul>
<li>给其他客户端发布订阅的信息；</li>
<li>订阅其他客户端发布的信息；</li>
<li>退订和订阅主题；</li>
<li>断开服务器连接。</li>
</ul>
<h4 id="MQTT服务端"><a href="#MQTT服务端" class="headerlink" title="MQTT服务端"></a>MQTT服务端</h4><p>MQTT服务端也称为消息代理，经常你会听到broker这个词。它可以实现一下功能：</p>
<ul>
<li>接收来自客户端的网络连接；</li>
<li>接受客户发布的应用信息；</li>
<li>处理来自客户端主题订阅和退订请求；</li>
<li>向订阅的客户端转发应用程序消息。</li>
</ul>
<h4 id="MQTT协议中的方法"><a href="#MQTT协议中的方法" class="headerlink" title="MQTT协议中的方法"></a>MQTT协议中的方法</h4><p>MQTT和HTTP一样，也定义了一些动作，来表示对确定资源进行操作。</p>
<ul>
<li><strong>Connect</strong>，等待于服务器建立连接；</li>
<li><strong>Disconnect</strong>，等待客户端完成所做的工作，并与服务器断开TCP/IP会话；</li>
<li><strong>Subscribe</strong>，主题订阅；</li>
<li><strong>UnSubscribe</strong>，主题取消订阅；</li>
<li><strong>Publish</strong>，发送消息。</li>
</ul>
<h3 id="移动端推送服务"><a href="#移动端推送服务" class="headerlink" title="移动端推送服务"></a>移动端推送服务</h3><p>消息推送服务目前已经是app开发中必备的一个功能了，及时地将消息推送给用户，可以使得用户不会错过重大新闻或者重要事件通知。一般，推送服务有三种实现方式：</p>
<ol>
<li>轮询方式。客户端不断的查询服务器，检索新内容。这种方式的缺点十分明显，如果轮询频率过快，会大量消耗网络带宽和电池；</li>
<li>长连接方式。客户端和服务端维持一条TCP/IP长连接，服务端向客户端push数据。这种方式可以避免轮询方式带来的性能问题，但是长连接依然会带来耗能问题。目前苹果的APNS和谷歌的GCM都是基于此方案来实现推送服务的；</li>
<li>SMS方式。当服务端有新内容的时候，会发送一条类似短信的指令传给客户端，客户端收到后从服务端下载新内容。由于运营商并没有免费开放这种指令，使用需要向运营商缴纳部分费用，所以并没有大量运用起来，但是这种方式非常的高效和及时。</li>
</ol>
<h4 id="iOS和Andorid推送的实现差异"><a href="#iOS和Andorid推送的实现差异" class="headerlink" title="iOS和Andorid推送的实现差异"></a>iOS和Andorid推送的实现差异</h4><p>之前我们说过，目前移动端的推送服务实现都是基于长连接方式实现的。服务端和客户端之间需要存在一条长连接来维持，当服务端主动推送内容给客户端时，客户端可以接收到该内容。</p>
<p><strong>iOS推送服务</strong></p>
<p>在iOS系统中，这个长连接是由系统去维护，iOS上所有应用的推送都是先将推送推到苹果推送服务器(APNs)上，应用需要推送功能时，需要先注册推送服务。其流程图如下所示：</p>
<p><img src="https://pic4.zhimg.com/f74c97ee64f0bf008e8c790206811f4f_b.png" alt="推送注册流程图"></p>
<p>首先，苹果会下发deviceToken，这是APNs推送实现的基础。APNs推送能够实现就是基于deviceToken来推送的，只有正确的deviceToken才会被APNs接受，一般第三方推送商就是来收集deviceToken来进行推送的。</p>
<p>当开始进行推送内容的时候，服务端会将内容先推到APNs，然后，剩下的就都交给APNs去做了，其推送内容流程如下：</p>
<p><img src="https://pic2.zhimg.com/4525ca70963895ab4fca064a537dbcd9_b.png" alt="推送注册流程图"></p>
<p>苹果这么做，不管是给用户还是开发者，带来的好处都是实实在在的：</p>
<ol>
<li>由于是系统级别的长连接，所以不会出现被杀死而不发推送的现象；</li>
<li>省电。不用每个app都去各自维护一个自己的长连接；</li>
<li>安全可靠。为了能够使用推送服务，必须先在开发者账号注册推送功能，这就大大降低了长连接滥用的场景。</li>
<li>对于开发来说，实现起来十分容易，服务端只要将正确的deviceToken和推送内容发送给APNs，然后客户端进行推送注册和逻辑处理就行了。</li>
</ol>
<p><strong>Android推送服务</strong></p>
<p>Android系统上，Google也推出了和APNS类似的服务，叫做GCM。但是由于国情原因(你懂得)，导致该服务在中国无法使用。所以，国内Andorid的普遍做法是自己维护一条长连接，和自己的推送服务器或者第三方推送商对接。</p>
<p>其实现原理APNs没有本质区别，但是由于一个设备通常需要维持多个长连接，所以在耗能这块，Andorid这块处理就不尽人意，并且，由于后台可以常驻，所以安全性这块也得不到保障。</p>
<p>除了类似APNs的实现，在Android上，也可以采用轮询方式，也可以简单实现推送功能。</p>
<h3 id="MQTT实现消息推送"><a href="#MQTT实现消息推送" class="headerlink" title="MQTT实现消息推送"></a>MQTT实现消息推送</h3><h4 id="iOS端实现"><a href="#iOS端实现" class="headerlink" title="iOS端实现"></a>iOS端实现</h4><p>对于iOS端使用MQTT来实现消息推送服务，比较常见的做法就是采用离线消息的方式去做，服务端发送推送消息，发送到APNs上，然后APNs通知客户端收到通知消息，客户端去服务端拉取最新消息列表，然后展示的界面上并处理相关逻辑。</p>
<h4 id="Android端实现"><a href="#Android端实现" class="headerlink" title="Android端实现"></a>Android端实现</h4><p>由于并不是做Android开发，并且Android方面采用方式五花八门，了解的做法是类似iOS的实现，利用MQTT将服务端和客户端建议一个长连接，然后服务端将消息直接推倒客户端上，客户端收到推送消息后，去服务端拉取最新的消息列表。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于移动设备来说，MQTT以低开销、低带宽著称，十分适合搭建推送服务。目前方案也比较成熟，希望未来MQTT的应用会越来越广！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MQTT简介&quot;&gt;&lt;a href=&quot;#MQTT简介&quot; class=&quot;headerlink&quot; title=&quot;MQTT简介&quot;&gt;&lt;/a&gt;MQTT简介&lt;/h3&gt;&lt;p&gt;MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。&lt;/p&gt;
&lt;h4 id=&quot;MQTT特性&quot;&gt;&lt;a href=&quot;#MQTT特性&quot; class=&quot;headerlink&quot; title=&quot;MQTT特性&quot;&gt;&lt;/a&gt;MQTT特性&lt;/h4&gt;&lt;p&gt;MQTT具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用发布／订阅消息模式，提供一对多消息发布；&lt;/li&gt;
&lt;li&gt;对负载内容屏蔽的消息传输；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用TCP/IP进行网络连接；&lt;/p&gt;
&lt;p&gt;  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具有三种消息发布服务质量选项；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；&lt;/li&gt;
&lt;li&gt;“至少一次”，可以确保消息收到，但消息可能会重复；&lt;/li&gt;
&lt;li&gt;“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；&lt;/p&gt;
&lt;p&gt;  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通知有关各方客户端异常中断的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关Keychain服务，你需要了解这些</title>
    <link href="http://yoursite.com/2017/02/20/%E6%9C%89%E5%85%B3Keychain%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B/"/>
    <id>http://yoursite.com/2017/02/20/有关Keychain服务，你需要了解这些/</id>
    <published>2017-02-20T06:15:44.000Z</published>
    <updated>2017-06-11T07:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。</p>
</blockquote>
<h3 id="NSUserDefaults不安全"><a href="#NSUserDefaults不安全" class="headerlink" title="NSUserDefaults不安全"></a>NSUserDefaults不安全</h3><p>NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。</p>
<p>当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。</p>
<p>所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。</p>
<a id="more"></a>
<h3 id="Keychain使用场景"><a href="#Keychain使用场景" class="headerlink" title="Keychain使用场景"></a>Keychain使用场景</h3><h4 id="存储隐私信息"><a href="#存储隐私信息" class="headerlink" title="存储隐私信息"></a>存储隐私信息</h4><p>在iOS系统中，最常用的keychain服务就是存储用户密码了。使用keychain保存用户密码最大的好处已经在上面说过，个人极力推荐这么做。</p>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>如果我们有多个app，它们之间需要共享一些数据，以提供更好的用户体验，那么使用Keychain群组可以实现。但前提是同一个公司的产品才能共享，比如<code>com.hyyy.test1</code>和<code>com.hyyy.test2</code>两个同一公司下的不同产品之前可以实现数据共享。</p>
<h4 id="设备唯一标示存储"><a href="#设备唯一标示存储" class="headerlink" title="设备唯一标示存储"></a>设备唯一标示存储</h4><p>在iOS中，为了在苹果的打压下获取唯一标示符，开发者们也是想尽了办法，目前最好的方式就是获取IDFV，并将其存储到keychain中。IDFV是设备区别应用提供商的，一般来说可以作为应用唯一标示符。但是IDFV缺陷就是当设备删除了该所有应用提供商的app之后，IDFV值会发生变化，所以IDFV+Keychain的组合目前被经常用到，来替代UDID的作用。特别是加上Keychain的共享服务，可以使应用提供商下的所有app下获取的IDFV都不会发生变化。这一服务可以说是目前最佳的识别用户的办法。</p>
<h4 id="其他用处"><a href="#其他用处" class="headerlink" title="其他用处"></a>其他用处</h4><p>当然，不同app的需求是不一样的，如果你需要存储一些信息，即使app删掉后也不会丢失，那么使用Keychain服务可以完美地实现这点。</p>
<h3 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h3><p>其实，所有的这些都是本人摸索出来的，并且实现了一个Swift3下的简单Keychain工具，叫<a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>。这个框架是参考大名鼎鼎的<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>和苹果官方的GenericKeychain实现的，如果您的Swfit项目需要使用到Keychain，希望这个可以帮到您，HYKeychainHelper操作起来也比较简单，如果您之前使用过SAMKeychain的话，那更容易了。</p>
<p><a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>的用法也比较简单，为了更好上手，语法采用和<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>基本一致。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/// query account&apos;s password</div><div class="line"></div><div class="line">HYKeychainHelper.password(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// add or update an account</div><div class="line"></div><div class="line">HYKeychainHelper.set(password: &quot;your_password&quot;, service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// delete an account</div><div class="line"></div><div class="line">HYKeychainHelper.deletePassword(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// all accounts</div><div class="line"></div><div class="line">HYKeychainHelper.allAccounts(forService: &quot;your_service_name&quot;)</div></pre></td></tr></table></figure>
<blockquote>
<p>对于更多的用法，请查看HYKeychainHelper获取更多细节。</p>
</blockquote>
<p>另外，对Keychain的了解难免有些遗漏，如果对Keychain有更多的看法，欢迎留言给我，对自己来说也是一种收获！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NSUserDefaults不安全&quot;&gt;&lt;a href=&quot;#NSUserDefaults不安全&quot; class=&quot;headerlink&quot; title=&quot;NSUserDefaults不安全&quot;&gt;&lt;/a&gt;NSUserDefaults不安全&lt;/h3&gt;&lt;p&gt;NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。&lt;/p&gt;
&lt;p&gt;当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。&lt;/p&gt;
&lt;p&gt;所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS事件机制</title>
    <link href="http://yoursite.com/2016/12/10/%E6%B5%85%E8%B0%88iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/12/10/浅谈iOS事件机制/</id>
    <published>2016-12-10T08:04:20.000Z</published>
    <updated>2017-07-12T08:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。</p>
</blockquote>
<h3 id="iOS中的事件"><a href="#iOS中的事件" class="headerlink" title="iOS中的事件"></a>iOS中的事件</h3><p>在iOS中事件分为3类：</p>
<ul>
<li>Touch Events(触摸事件。包括单击、双击等)；</li>
<li>Motion Events(重力感应、晃动手机等等)；</li>
<li>Remote Events(远程事件，比如耳机音量按键的触发)。</li>
</ul>
<p>不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。</p>
<h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><p>在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。</p>
<p><code>UIResponder</code>并不是一个视图，是继承<code>NSObject</code>的一个对象。</p>
<a id="more"></a>
<p>我们先看下<code>UIResponder</code>对外暴露的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder : NSObject &lt;UIResponderStandardEditActions&gt;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</div><div class="line">#else</div><div class="line">- (nullable UIResponder*)nextResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</div><div class="line">#else</div><div class="line">- (BOOL)canBecomeFirstResponder;    // default is NO</div><div class="line">#endif</div><div class="line">- (BOOL)becomeFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</div><div class="line">#else</div><div class="line">- (BOOL)canResignFirstResponder;    // default is YES</div><div class="line">#endif</div><div class="line">- (BOOL)resignFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</div><div class="line">#else</div><div class="line">- (BOOL)isFirstResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">// Generally, all responders which do custom touch handling should override all four of these methods.</div><div class="line">// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each</div><div class="line">// touch it is handling (those touches it received in touchesBegan:withEvent:).</div><div class="line">// *** You must handle cancelled touches to ensure correct behavior in your application.  Failure to</div><div class="line">// do so is very likely to lead to incorrect behavior or crashes.</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);</div></pre></td></tr></table></figure>
<p>可以说<code>UIResponder</code>是所有可以响应事件的基类，包括<code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>和<code>UIApplication</code>。我们可以看下这些类的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// UIView.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIView : UIResponder</div><div class="line"></div><div class="line">// UIViewController.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIViewController : UIResponder</div><div class="line"></div><div class="line">// UIWindow.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView</div><div class="line"></div><div class="line">// UIApplication.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIApplication : UIResponder</div></pre></td></tr></table></figure>
<p>可以看到，都继承自<code>UIResponder</code>。可以看出，事件响应的产生来自<code>UIResponder</code>，并且系统会自动调用，除了自定义需求。</p>
<p>比如在自定义的<code>UIView</code>子类中，重写下面的四个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesBegan触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesEnded触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    // 某个系统事件打断触摸过程，系统会自动调用这个方法，比如电话接入等。</div><div class="line">    NSLog(@&quot;UITestView=====touchesCancelled触发&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现，当在这个view上做点击、滑动操作时，会触发某些方法的调用。我们可以在这里处理view的触摸事件。比如我们需要实现自定义view可以进行拖拽，那么可以在<code>touchesMoved</code>方法里做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line"></div><div class="line">    UITouch *touch = [touches anyObject];</div><div class="line"></div><div class="line">    CGPoint currentPoint = [touch locationInView:self];</div><div class="line">    CGPoint previousPoint = [touch previousLocationInView:self];</div><div class="line"></div><div class="line">    CGFloat offsetX = currentPoint.x - previousPoint.x;</div><div class="line">    CGFloat offsetY = currentPoint.y - previousPoint.y;</div><div class="line"></div><div class="line">    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，我们来总结一下事件响应的产生，从系统底层开始。</p>
<ol>
<li>iOS基于Runloop，其实注册了一个Source1用来接收系统事件；</li>
<li>当手机硬件发生变化，比如触摸、摇晃等，首先通过系统IO来生成一个Event，然后转发给需要的App进程，这时候上面注册的Source1就会触发；</li>
<li>在Source1回调中，会触发Source0，Source0会对Event进行处理，对该Event进行内部分发，并封装成UIEvent，这时候就会调用基本的UIResponder方法；</li>
<li>UIEvent会传递给touchesBegin/Move/End/Cancel，或者<code>UIButton</code>点击等，这些方法会被执行。</li>
</ol>
<h3 id="事件响应传递"><a href="#事件响应传递" class="headerlink" title="事件响应传递"></a>事件响应传递</h3><p>在iOS视图组成中，可以看到其实是一个树状结构，如下图：</p>
<p><img src="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Art/view_hierarchy_enclose.jpg" alt="image"></p>
<p>事件响应的传递，其实是参照视图结构，从父控件到子控件这样一个顺序来做的，也就是UIApplication-&gt;UIWindow-&gt;superView-&gt;subView，如果父控件不能接收UIEvent事件，那么其下的子控件肯定不能接收到UIEvent事件。</p>
<p>不过在传递的过程中，如果遇到：</p>
<ol>
<li>该视图不允许交互(userInteractionEnabled = NO);</li>
<li>该视图hidden是YES;</li>
<li>该视图透明度在0~0.01之间。</li>
</ol>
<p>以上三种情况任意一种，该视图都接收不到Touch事件。</p>
<h4 id="如何找到合适的view"><a href="#如何找到合适的view" class="headerlink" title="如何找到合适的view"></a>如何找到合适的view</h4><p>当用户点击屏幕后，系统就会生成一个UIEvent对象，这个事件会放在事件队列中，当处理对象的时候，UIApplication对象会从队列取出UIEvent对象，然后进行分发，以UIApplication-&gt;UIWindow-&gt;superView-&gt;subView的顺序来。具体顺序如下：</p>
<ol>
<li>首先判断主窗口可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上；</li>
<li>遍历自己的子控件，看子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>重复上一步操作，判断子控件的子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>循环遍历之后，如果最后没有发现合适的子控件，那么其本身就是合适的view。</li>
</ol>
<p>另外，这里涉及到两个两个重要的传递方法，分别是：</p>
<ul>
<li><code>hitTest:withEvent:</code>;</li>
<li><code>pointInside</code>。</li>
</ul>
<p>我们一个一个来说。</p>
<h4 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h4><p><code>hitTest:withEvent:</code>是做事件传递的，下面简称<code>hit-Test</code>。当手指触摸屏幕，发生触摸事件，该UIEvent对象的传递顺序如下所示：</p>
<blockquote>
<p>发生触摸事件 -&gt; 生成UIEvent对象 -&gt; UIWindow hit-Test方法触发 -&gt; superView hit-Test方法触发 -&gt; subView hit-Test方法触发 -&gt; 返回合适的view。</p>
</blockquote>
<p>事件传递给主窗口后，主窗口会将事件往下传递，然后才会在自身查找合适的view。需要注意的是事件传递给window和view后，就会调用hit-Test方法，所以是先将事件传递给子控件，子控件调用hit-Test方法验证自己有没有合适的View，如果父控件是最合适的view，那子控件的hit-Test还是会走的，这里需要注意一下的。</p>
<p>有时候我们需要重写hit-Test，来改变最适合的view，那么请记住修改规则，需要谁成为最合适的view，就重写其父视图的hit-Test方法。</p>
<p>另外，如果去验证问题的话就会发现，每次hit-Test方法会走两次，根据苹果官方的回应，这个是正常的，不用去管。</p>
<h4 id="pointInside"><a href="#pointInside" class="headerlink" title="pointInside"></a>pointInside</h4><p><code>pointInside</code>方法是用来判断触摸点在不在当前view上，如果返回YES，说明在其坐标上；返回NO，说明不在其坐标上。一般和hit-Test方法是成对出现的。</p>
<p>这个方法也比较好理解，需要注意的事，和hit-Test类似，也是会调用两次的。</p>
<p>另外，这两个方法的调用，都是在<code>touchesBegan</code>、<code>touchesMoved</code>、<code>touchesEnded</code>之前发生的，这是因为touch事件的发生，是在已确认合适的view后发生的，所以才会是这样。</p>
<h3 id="事件机制应用"><a href="#事件机制应用" class="headerlink" title="事件机制应用"></a>事件机制应用</h3><p>对于事件机制的应用，网上已经很多，接下来只说下自己经常用到的场景，其实原理都是一样的。</p>
<h4 id="查看当前的触摸点"><a href="#查看当前的触摸点" class="headerlink" title="查看当前的触摸点"></a>查看当前的触摸点</h4><p>在日常开发调试中，有时候需要时时去监听当前点击的坐标值。我们可以重写系统<code>UIApplication</code>的<code>sendEvent</code>方法，来实现此操作。</p>
<p>首先我们继承<code>UIApplication</code>实现一个子类，名为<code>HYApplication</code>，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation HYApplication</div><div class="line"></div><div class="line">- (void)sendEvent:(UIEvent *)event &#123;</div><div class="line">    [super sendEvent:event];</div><div class="line"></div><div class="line">    if (event.type == UIEventTypeTouches) &#123;</div><div class="line">        if ([[event.allTouches anyObject] phase] == UITouchPhaseBegan) &#123;</div><div class="line">            // 打印出来屏幕触摸坐标</div><div class="line">            CGPoint point = [[event.allTouches anyObject] locationInView:[self mainWindow]];</div><div class="line">            NSLog(@&quot;touching point: %@&quot;, NSStringFromCGPoint(point));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line">// 获取主窗口</div><div class="line">- (UIWindow *)mainWindow &#123;</div><div class="line">    if ([UIApplication sharedApplication].delegate.window) &#123;</div><div class="line">        return [UIApplication sharedApplication].delegate.window;</div><div class="line">    &#125;else &#123;</div><div class="line">        return [UIApplication sharedApplication].windows[0];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>重写<code>UIApplication</code>的<code>sendEvent</code>方法，进行简单改造，然后修改程序入口main函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;HYApplication.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, NSStringFromClass([HYApplication class]), NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>HYApplication</code>添加进去，运行程序，点击任意位置都会打印出坐标了，是不是很方便呢。</p>
<p>其实这里还可以实现其他操作，原理都是一样的。</p>
<h4 id="扩大UIButton的点击区域"><a href="#扩大UIButton的点击区域" class="headerlink" title="扩大UIButton的点击区域"></a>扩大UIButton的点击区域</h4><p>有时候给的设计图上，一个按钮图标会很小，点击区域很小，有时候很别扭。这时候我们就可以重写<code>pointInside</code>方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    BOOL isInside = CGRectContainsPoint(HitTestingBounds(self.bounds, CGRectGetWidth(self.bounds) + 50, CGRectGetHeight(self.bounds) + 50), point);</div><div class="line">    return isInside;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CGRect HitTestingBounds(CGRect bounds, CGFloat minimumHitTestWidth, CGFloat minimumHitTestHeight) &#123;</div><div class="line">    CGRect hitTestingBounds = bounds;</div><div class="line">    if (minimumHitTestWidth &gt; bounds.size.width) &#123;</div><div class="line">        hitTestingBounds.size.width = minimumHitTestWidth;</div><div class="line">        hitTestingBounds.origin.x -= (hitTestingBounds.size.width - bounds.size.width)/2;</div><div class="line">    &#125;</div><div class="line">    if (minimumHitTestHeight &gt; bounds.size.height) &#123;</div><div class="line">        hitTestingBounds.size.height = minimumHitTestHeight;</div><div class="line">        hitTestingBounds.origin.y -= (hitTestingBounds.size.height - bounds.size.height)/2;</div><div class="line">    &#125;</div><div class="line">    return hitTestingBounds;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样以来，我们把范围扩大到+50的范围，使得点击起来不在那么别扭。</p>
<h4 id="UIResponder分类"><a href="#UIResponder分类" class="headerlink" title="UIResponder分类"></a>UIResponder分类</h4><p>这个最早是在环信的Demo里看到的，个人觉得还是挺好用。是实现了一个<code>UIResponder</code>的category。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder (AppResponse)</div><div class="line"></div><div class="line">/**</div><div class="line"> 事件路由，层级传递</div><div class="line"></div><div class="line"> @param eventName 事件名</div><div class="line"> @param userInfo 携带信息</div><div class="line"> */</div><div class="line">-(void)routerEvent:(NSString *)eventName userInfo:(id)userInfo;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIResponder (AppResponse)</div><div class="line"></div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    [[self nextResponder] routerEvent:eventName userInfo:userInfo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个简单的category，对外暴露了一个方法，用来传递事件。正常开发中，我们传递事件一般都是用delegate或者block去做，比如我们需要从view里传递一个事件到controller层，如果有了这个category，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// view层添加一个点击事件，然后事件方法内部调用routerEvent实现事件传递。</div><div class="line">- (void)clickedBtnHandler &#123;</div><div class="line">    [self routerEvent:@&quot;clicked_btn&quot; userInfo:param];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后在controller层监听这个方法，然后在回调里处理相关逻辑。</div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    if ([@&quot;clicked_btn&quot; isEqualStirng:eventName]) &#123;</div><div class="line">        // 拿到获取到的userInfo，来处理点击后的事件。</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样可以使得点击事件和回调有个统一的出发点和着陆点，代码比较好管理，易读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于iOS的事件机制，就说到这里。事件机制代表了我们使用iOS系统的所有操作出发点，也是比较重要的，这块还需要多多理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;iOS中的事件&quot;&gt;&lt;a href=&quot;#iOS中的事件&quot; class=&quot;headerlink&quot; title=&quot;iOS中的事件&quot;&gt;&lt;/a&gt;iOS中的事件&lt;/h3&gt;&lt;p&gt;在iOS中事件分为3类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Touch Events(触摸事件。包括单击、双击等)；&lt;/li&gt;
&lt;li&gt;Motion Events(重力感应、晃动手机等等)；&lt;/li&gt;
&lt;li&gt;Remote Events(远程事件，比如耳机音量按键的触发)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。&lt;/p&gt;
&lt;h3 id=&quot;事件的产生&quot;&gt;&lt;a href=&quot;#事件的产生&quot; class=&quot;headerlink&quot; title=&quot;事件的产生&quot;&gt;&lt;/a&gt;事件的产生&lt;/h3&gt;&lt;p&gt;在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIResponder&lt;/code&gt;并不是一个视图，是继承&lt;code&gt;NSObject&lt;/code&gt;的一个对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关Block的一点总结</title>
    <link href="http://yoursite.com/2016/11/16/%E6%9C%89%E5%85%B3Block%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/11/16/有关Block的一点总结/</id>
    <published>2016-11-16T02:59:59.000Z</published>
    <updated>2017-07-16T03:02:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>Block这种东西，基本上天天都会看到，最近闲下来，总结一下Block的基本知识。</p>
</blockquote>
<h3 id="Block基础用法"><a href="#Block基础用法" class="headerlink" title="Block基础用法"></a>Block基础用法</h3><p>从苹果官方文档来看，Block是一个OC对象，其实可以作为一个可以保存代码块的特殊对象来理解。在合适的时机去执行这块代码。</p>
<p>Block的种类有三种，无参数无返回值的Block、有参数无返回值的Block和有参数和有返回值的Block。</p>
<h4 id="无参数无返回值的Block"><a href="#无参数无返回值的Block" class="headerlink" title="无参数无返回值的Block"></a>无参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void (^(testBlock))() = ^() &#123;</div><div class="line">    NSLog(@&quot;textBlock&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">testBlock();</div></pre></td></tr></table></figure>
<h4 id="有参数无返回值的Block"><a href="#有参数无返回值的Block" class="headerlink" title="有参数无返回值的Block"></a>有参数无返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    NSLog(@&quot;%@&quot;, appendStr);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">appendString(@&quot;123&quot;, @&quot;456&quot;);</div></pre></td></tr></table></figure>
<h4 id="有参数有返回值的Block"><a href="#有参数有返回值的Block" class="headerlink" title="有参数有返回值的Block"></a>有参数有返回值的Block</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSString* (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &#123;</div><div class="line">    NSString *appendStr = [NSString stringWithFormat:@&quot;%@%@&quot;, str1, str2];</div><div class="line">    return appendStr;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;, appendString(@&quot;123&quot;, @&quot;456&quot;));</div></pre></td></tr></table></figure>
<p>这些事Block的基本用法，不过并不是这篇文章的关键，在总结Block的关键知识点之前，我们先来回顾一下iOS的内存分配机制。</p>
<a id="more"></a>
<h3 id="iOS内存分配"><a href="#iOS内存分配" class="headerlink" title="iOS内存分配"></a>iOS内存分配</h3><p>在开始之前，先来讲讲iOS程序中内存分配的知识。搬张图来看看内存区域的划分。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1232160-0db68b7366e194e3.png?imageMogr2/auto-orient/strip%7CimageView2/2" alt="内存分配"></p>
<h4 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h4><p>栈是向低地址扩展的数据结构，是一块连续的内存区域。其栈顶和栈的最大容量是系统事先规定好的，如果申请空间超过栈的剩余空间，就会提示栈溢出，一般栈空间是很小的，用来存放函数的参数值，局部变量等等。</p>
<h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆和栈相反，是向高地址扩展的数据结构，并且不是一块连续的内存区域。对于堆内存来讲，系统会有一张链表用来记录空闲内存地址的，当系统收到堆内存申请时，会遍历该链表，找到第一个空闲内存大于申请空间的堆结点地址，将空间分配给使用者。和栈相比，堆的大小只受限于操作系统的虚拟内存大小，目前来说已经足够大，所以空间充足。</p>
<p>堆内存的分配和释放是由开发者去控制的，在iOS中，一般我们创建一个对象，就是存放在堆中的，其分配内存是用alloc方法实现，其内存释放就是使用release方法来进行内存释放。</p>
<h4 id="全局区"><a href="#全局区" class="headerlink" title="全局区"></a>全局区</h4><p>全局区有时候也叫静态区，是用来存储全局变量和静态变量的。全局区包括两块区域，一块是存放未初始化过全局变量和静态变量的，另一块是存放已经初始化过的全局变量和静态变量。</p>
<p>在一些其他文章中，全局区属于数据区的范畴，下面讲到的常量区也属于数据区范畴。</p>
<h4 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h4><p>常量区顾名思义，存放一些程序是用到的常量，程序结束后由系统释放。</p>
<h4 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h4><p>代码区是存放程序运行的二进制代码的。</p>
<p>一般app启动之后，全局区、常量区和代码区都已经固定，分配完毕。变化的是堆区和栈区的内存分配。当内存已经释放，但是还有指针指向这块，这时会造成野指针。</p>
<p>盗用一位前辈总结的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//main.cpp</div><div class="line">int a = 0; // 全局初始化区</div><div class="line">char *p1; // 全局未初始化区</div><div class="line">main &#123;</div><div class="line">    int b; // 栈</div><div class="line">    char s[] = &quot;abc&quot;; // 栈</div><div class="line">    char *p2; // 栈</div><div class="line">    char *p3 = &quot;123456&quot;; // 123456\0在常量区，p3在栈上</div><div class="line">    static int c =0； // 全局静态初始化区</div><div class="line">    p1 = (char *)malloc(10);</div><div class="line">    p2 = (char *)malloc(20); // 分配得来的10和20字节的区域就在堆区</div><div class="line">    strcpy(p1, &quot;123456&quot;); // 123456\0在常量区，这个函数的作用是将&quot;123456&quot; 这串字符串复制一份放在p1申请的10个字节的堆区域中。</div><div class="line">    // p3指向的&quot;123456&quot;与这里的&quot;123456&quot;可能会被编译器优化成一个地址。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Block知识点总结"><a href="#Block知识点总结" class="headerlink" title="Block知识点总结"></a>Block知识点总结</h3><h4 id="Block捕获外部变量"><a href="#Block捕获外部变量" class="headerlink" title="Block捕获外部变量"></a>Block捕获外部变量</h4><p>首先，Block捕获外部变量仅仅只会捕获闭包里用到的值，没有用到的并不会去捕获。</p>
<p>如果外部变量是全局变量或者是静态全局变量，Block捕获之后，由于是全局的，在闭包结束之后，其改变的值仍然可以保存下来，所以如果Block捕获外部变量是全局的，在Block回调内部修改了该变量，可以直接修改，不用加<code>__block</code>。</p>
<p>如果外部变量是静态变量，那么修改也是不需要<code>__block</code>的，因为静态变量传递给Block的是内存地址，所以Block也可以直接修改该值。</p>
<p>但是，如果外部变量是自动变量的话，是不能直接修改的，是因为Block捕获到的是自动变量的值，并非内存地址。如果需要修改，那么只有加上<code>__block</code>才会生效。</p>
<p>所以，可以总结一下，在Block中有两种可以修改值的方式，一是传递内存地址到Block中，二是使用<code>__blcok</code>修饰。</p>
<h4 id="Block常见类型"><a href="#Block常见类型" class="headerlink" title="Block常见类型"></a>Block常见类型</h4><p><strong>_NSConcreteStackBlock</strong></p>
<p>这是保存在栈中的block，当函数返回时该block会销毁。这种block的特点是只会执行一次就出栈了，可以访问外部变量。</p>
<p><strong>_NSConcreteMallocBlock</strong></p>
<p>这是保存在堆中的block，当引用计数为0时会被销毁。该类型的block都是由<code>_NSConcreteStackBlock</code>类型的block从栈中复制到堆中形成的。</p>
<p>该类型的block可以执行多次，当需要执行多次时，会把block从栈上复制到堆上，提供多次使用。</p>
<p><strong>_NSConcreteGlobalBlock</strong></p>
<p>这是全局Block，不会访问任何外部变量，不会涉及到任何拷贝。要么是一个空block，它既不在堆中，也不再栈中。</p>
<h4 id="copy-和dispose"><a href="#copy-和dispose" class="headerlink" title="copy()和dispose()"></a>copy()和dispose()</h4><p>上面说过，如果需要多次使用该block，那么需要将block拷贝到堆上，提供多次使用。这个拷贝操作其实就是调用<code>Block_copy()</code>函数来实现。</p>
<p>有拷贝就会有释放，<code>Block_copy()</code>对应的是<code>Block_release()</code>，其对应的辅助函数就是<code>copy()</code>和<code>dispose()</code>。</p>
<h4 id="block中的weakSelf和strongSelf"><a href="#block中的weakSelf和strongSelf" class="headerlink" title="block中的weakSelf和strongSelf"></a>block中的weakSelf和strongSelf</h4><p>需要使用weakSelf，是因为防止循环引用，一般使用block的场景中，self会对block强引用，在block内部回调中，block又强引用了self，所以造成循环引用，使用weakSelf，可以打破这一闭环，使得block内部回调中不会对self发生强引用，就解决了问题。</p>
<p>使用strongSelf，是因为外部使用了weakSelf，在Block内部回调中，这个weakSelf可能会被释放，造成接下来的操作无法完成，如果是KVO操作，还是引发崩溃。所以在Block内部需要使用strongSelf，防止weakSelf提前释放。需要注意的是，这个strongSelf的作用域在block内部回调，出了这个回调就会失效，所以这么写既能正常释放，又不会崩溃。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Block这种东西，基本上天天都会看到，最近闲下来，总结一下Block的基本知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Block基础用法&quot;&gt;&lt;a href=&quot;#Block基础用法&quot; class=&quot;headerlink&quot; title=&quot;Block基础用法&quot;&gt;&lt;/a&gt;Block基础用法&lt;/h3&gt;&lt;p&gt;从苹果官方文档来看，Block是一个OC对象，其实可以作为一个可以保存代码块的特殊对象来理解。在合适的时机去执行这块代码。&lt;/p&gt;
&lt;p&gt;Block的种类有三种，无参数无返回值的Block、有参数无返回值的Block和有参数和有返回值的Block。&lt;/p&gt;
&lt;h4 id=&quot;无参数无返回值的Block&quot;&gt;&lt;a href=&quot;#无参数无返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;无参数无返回值的Block&quot;&gt;&lt;/a&gt;无参数无返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;void (^(testBlock))() = ^() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;textBlock&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;testBlock();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;有参数无返回值的Block&quot;&gt;&lt;a href=&quot;#有参数无返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;有参数无返回值的Block&quot;&gt;&lt;/a&gt;有参数无返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;void (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSString *appendStr = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, str1, str2];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, appendStr);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;appendString(@&amp;quot;123&amp;quot;, @&amp;quot;456&amp;quot;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;有参数有返回值的Block&quot;&gt;&lt;a href=&quot;#有参数有返回值的Block&quot; class=&quot;headerlink&quot; title=&quot;有参数有返回值的Block&quot;&gt;&lt;/a&gt;有参数有返回值的Block&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString* (^(appendString))(NSString *str1, NSString *str2) = ^(NSString *str1, NSString *str2) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSString *appendStr = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, str1, str2];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return appendStr;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, appendString(@&amp;quot;123&amp;quot;, @&amp;quot;456&amp;quot;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这些事Block的基本用法，不过并不是这篇文章的关键，在总结Block的关键知识点之前，我们先来回顾一下iOS的内存分配机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>load和initialize的特殊之处</title>
    <link href="http://yoursite.com/2016/10/03/load%E5%92%8Cinitialize%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84/"/>
    <id>http://yoursite.com/2016/10/03/load和initialize的特殊之处/</id>
    <published>2016-10-03T03:56:22.000Z</published>
    <updated>2017-07-16T03:57:30.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在NSObject.h中提供了两个特殊的类方法，load和initialize。帮助我们进行类的加载和初始化。</p>
</blockquote>
<p>既然是进行类的加载和初始化的，那么它们的调用时机是什么，又有什么区别呢？我们一起来看下。</p>
<h3 id="load"><a href="#load" class="headerlink" title="+load"></a>+load</h3><p>我们先做以下实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Father is loaded&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Load.h</div><div class="line">+ (void)load &#123;</div><div class="line">    NSLog(@&quot;Son+Load is loaded&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">iOSTest[1120:83646] Father is loaded</div><div class="line">iOSTest[1120:83646] Son is loaded</div><div class="line">iOSTest[1120:83646] Son+Load is loaded</div></pre></td></tr></table></figure>
<p>说明，一个类如果实现了<code>load</code>方法，那么调用该方法之前，会先找父类的<code>load</code>方法，然后在调用自己的<code>load</code>方法。</p>
<p>如果是这个类的<code>category</code>的话，那么会先调用自己的<code>load</code>方法，然后再调用<code>category</code>的<code>load</code>方法。</p>
<a id="more"></a>
<p>需要注意的事，<code>load</code>方法的本质是直接执行函数指针的，因此不像普通方法调用，会走<code>objc_msgSend</code>这套流程，<code>load</code>方法并不会走<code>objc_msgSend</code>这套流程，有兴趣的同学可以看下源码，这里就不讨论那么多了。</p>
<p>另外就是有关执行顺序的问题，<code>load</code>方法执行，先是父类方法执行，然后是子类，最后是<code>category</code>中的方法执行。如果是不相关的两个类中<code>load</code>方法的执行顺序，和<code>Build Phases</code>中的<code>Compile Sources</code>文件顺序有关，放在前面的先执行。</p>
<p>还有一点很关键，<code>load</code>方法只会被调用一次，<code>initialize</code>也是的。</p>
<p>对于<code>load</code>方法的实践，大多是基于它开发中调用时间最早的特性。目前用的最多的就是Method Swizzling。比如经常用的Controller方法替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation UIViewController (Tracking)</div><div class="line"></div><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        Class class = [self class];</div><div class="line"></div><div class="line">        SEL originalSelector = @selector(viewWillAppear:);</div><div class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</div><div class="line"></div><div class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        // When swizzling a class method, use the following:</div><div class="line">        // Class class = object_getClass((id)self);</div><div class="line">        // ...</div><div class="line">        // Method originalMethod = class_getClassMethod(class, originalSelector);</div><div class="line">        // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</div><div class="line"></div><div class="line">        BOOL didAddMethod =</div><div class="line">            class_addMethod(class,</div><div class="line">                originalSelector,</div><div class="line">                method_getImplementation(swizzledMethod),</div><div class="line">                method_getTypeEncoding(swizzledMethod));</div><div class="line"></div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                swizzledSelector,</div><div class="line">                method_getImplementation(originalMethod),</div><div class="line">                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Method Swizzling</div><div class="line"></div><div class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [self xxx_viewWillAppear:animated];</div><div class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>不过，除了Method Swizzling，其他的东西还是少放，调用<code>load</code>方法的时候环境并不安全，也不要放线程堵塞的代码上去。</p>
<h3 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h3><p>一样，我们先做个实验：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Load is initialized&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们什么先都不做，运行可以发现，什么都没打印。于<code>load</code>不同，<code>initialize</code>是惰性的，只会在第一次调用类的方法时去调用。</p>
<p>然后我们在修改一下上面的代码，去掉category那块，然后在主函数里创建一个Father对象，查看打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Father *father = [[Father alloc] init];</div></pre></td></tr></table></figure>
<p>运行可以发现，控制台打印出了一条，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div></pre></td></tr></table></figure>
<p>然后，我们修改主函数，创建一个Son对象，运行之后发现，打印了两条：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son is initialized</div></pre></td></tr></table></figure>
<p>可以看到，创建子类对象会调用父类的<code>initialize</code>方法，并且是先执行父类的，然后执行子类的。那么我们可以得出，<code>initialize</code>方法的执行顺序是先执行父类的，然后执行子类的。</p>
<p>接下来我们还原代码，添加上catagory那块，在main函数里创建一个Son对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// Son.h (继承Father类)</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Father.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Father is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// Son+Initialize.h</div><div class="line">+ (void)initialize &#123;</div><div class="line">    NSLog(@&quot;Son+Initialize is initialized&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// main.h</div><div class="line">Son *son = [[Son alloc] init];</div></pre></td></tr></table></figure>
<p>运行后，发现，控制台仍然只打印了两条日志，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>关键点来了，我们发现，和<code>load</code>方法不一样，并没有打印三条日志，并且没有打印出Son子类的<code>initialize</code>方法。这是比较关键的，是因为<code>initialize</code>方法只会在第一次调用当前类的时候被调用，并且只会调用一次。既然走了Son的category的方法，那么就并不会走其本身的<code>initialize</code>方法了。</p>
<p>接下来我们继续修改代码，在主函数里多创建几个Son对象，发现日志没有变化，仍旧只是两条打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father is initialized</div><div class="line">Son+Initialize is initialized</div></pre></td></tr></table></figure>
<p>这说明<code>initialize</code>方法只会走一次，这块和<code>load</code>方法还是有点像的。</p>
<p>一般<code>initialize</code>的使用场景比较少，如果需要在类调用前需要定义一些常量，可以在这里做。并且<code>initialize</code>方法内部也是线程安全的，这个也很关键。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在NSObject.h中提供了两个特殊的类方法，load和initialize。帮助我们进行类的加载和初始化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然是进行类的加载和初始化的，那么它们的调用时机是什么，又有什么区别呢？我们一起来看下。&lt;/p&gt;
&lt;h3 id=&quot;load&quot;&gt;&lt;a href=&quot;#load&quot; class=&quot;headerlink&quot; title=&quot;+load&quot;&gt;&lt;/a&gt;+load&lt;/h3&gt;&lt;p&gt;我们先做以下实验：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// Son.h (继承Father类)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Son is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Father.h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Father is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// Son+Load.h&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;+ (void)load &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Son+Load is loaded&amp;quot;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到打印结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Father is loaded&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Son is loaded&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;iOSTest[1120:83646] Son+Load is loaded&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;说明，一个类如果实现了&lt;code&gt;load&lt;/code&gt;方法，那么调用该方法之前，会先找父类的&lt;code&gt;load&lt;/code&gt;方法，然后在调用自己的&lt;code&gt;load&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;如果是这个类的&lt;code&gt;category&lt;/code&gt;的话，那么会先调用自己的&lt;code&gt;load&lt;/code&gt;方法，然后再调用&lt;code&gt;category&lt;/code&gt;的&lt;code&gt;load&lt;/code&gt;方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>初识Runtime</title>
    <link href="http://yoursite.com/2016/09/05/%E5%88%9D%E8%AF%86Runtime/"/>
    <id>http://yoursite.com/2016/09/05/初识Runtime/</id>
    <published>2016-09-05T12:12:57.000Z</published>
    <updated>2017-07-29T00:24:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h3><p>面向对象的语言有很多种，比如Java、C++和Objective-C。但是面向对象的语言分两种，一种是函数调用型，另一种是消息结构型。其中Java和C++属于函数调用型，而OC属于消息结构型。为了支持消息结构，OC和其他语言不同的是，不仅仅只有一个编译器，还存在一个叫做runtime组件的东西，它的出现目的是简化编译器的功能，在OC中，基本的重要功能都是runtime组件完成的，所有的内存管理方法，对象所需的数据结构和方法都在其中。</p>
<p>这么一来，我们只需要更新runtime组件，就可以达到修改应用功能，我们使用的JSPatch、Aspects就是利用了这一功能。如果要在函数调用型语言上完成这些事，由于这些工作是在编译期完成的，所以必须重新编译代码才能完成。</p>
<p>在我们平时编写OC代码时，其实已经有意无意在和runtime打交道了，比如：</p>
<ul>
<li>平时写的类和方法，并且使用它们，其实runtime已经在悄悄地给我们提供支持；</li>
<li>当我们使用到<code>isKindOfClass</code>、<code>isMemberOfClass</code>、<code>conformsToProtocol</code>和<code>respondsToSelector</code>这些方法时，其实就是在调底层runtime的API；</li>
</ul>
<h3 id="对象模型"><a href="#对象模型" class="headerlink" title="对象模型"></a>对象模型</h3><p>Objective-C类是用Class类型表示的，实际上是一个指向<code>objc_class</code>结构体的指针。打开<code>objc.h</code>即可看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure>
<p>点进<code>objc_class</code>，可以看到该结构体定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;     // 父类</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;     // 类名</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     // 类的版本信息，默认为0</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     // 类信息，提供运行时使用一些标示位</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     // 类的实例变量大小</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="ISA指针"><a href="#ISA指针" class="headerlink" title="ISA指针"></a>ISA指针</h4><p>打开<code>NSObject.h</code>文件，查看interface，我们可以看到下面这个定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@interface NSObject &lt;NSObject&gt; &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，基类<code>NSObject</code>只有这么一个成员变量，我先看下官方是怎么定义的：</p>
<blockquote>
<p>Every object has an isa instance variable that identifies the object’s class. The runtime uses this pointer to determine the actual class of the object when it needs to.（简单翻译：每个对象都有一个isa变量来标示实例对象，当需要使用到这个对象时，runtime使用isa指针来确定是哪个实例对象）</p>
</blockquote>
<p>那么我们可以得出，每个对象都会有个isa指针，并且指向该对象的类。也就是isa指针是用来作为对象标示的。</p>
<p>但是，当我们查看<code>Class</code>结构时，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct objc_class &#123;</div><div class="line">    Class isa  OBJC_ISA_AVAILABILITY;</div><div class="line"></div><div class="line">#if !__OBJC2__</div><div class="line">    Class super_class                                        OBJC2_UNAVAILABLE;     // 父类</div><div class="line">    const char *name                                         OBJC2_UNAVAILABLE;     // 类名</div><div class="line">    long version                                             OBJC2_UNAVAILABLE;     // 类的版本信息，默认为0</div><div class="line">    long info                                                OBJC2_UNAVAILABLE;     // 类信息，提供运行时使用一些标示位</div><div class="line">    long instance_size                                       OBJC2_UNAVAILABLE;     // 类的实例变量大小</div><div class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div><div class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div><div class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div><div class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div><div class="line">#endif</div><div class="line"></div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p>我们看到，<code>objc_class</code>里面也有一个isa指针，那么这个isa指针是干什么的呢？在OC中，类也是一个对象，那可以这么说，类也是另外一个类的实例，这个类叫做<code>metaclass</code>，中文叫元类。元类保存类方法列表，就是说，当我们去调用一个类方法时，先会在元类中找，如果没有找到，则会在元类的父类中找。</p>
<p>那么问题来了？元类的isa指针指向哪里呢？所有的元类的isa指针都会指向一个根元类，同时根元类的isa指针指向自己。</p>
<p>关于这里的资料，推荐唐巧大哥的博客<a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a>，有关isa详细的介绍，可以参考参考。</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>在<code>objc_class</code>结构体中，有下面一条定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表</div></pre></td></tr></table></figure>
<p>ivars值包含了类的所有成员变量，每个元素里面是一个Ivar。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_ivar *Ivar;</div></pre></td></tr></table></figure>
<p>有关Ivar，也是一个结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar &#123;</div><div class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</div><div class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>objc_ivar</code>里定义了成员变量的名称、类型和偏移字节。有关偏移字节的介绍，可以查看<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="external">Objective-C类成员变量深度剖析
</a>，说的很好，同时也回答了<code>为什么Objective-C类不能动态添加成员变量？</code>这个问题。</p>
<h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><p>在Class的定义里，有一个关于方法的属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表</div></pre></td></tr></table></figure>
<p>顾名思义，<code>methodLists</code>内包含的是该对象的方法列表。我们查看<code>objc_method_list</code>的介绍，可以看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">struct objc_method_list &#123;</div><div class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</div><div class="line"></div><div class="line">    int method_count                                         OBJC2_UNAVAILABLE;</div><div class="line">#ifdef __LP64__</div><div class="line">    int space                                                OBJC2_UNAVAILABLE;</div><div class="line">#endif</div><div class="line">    /* variable length structure */</div><div class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了一些基本介绍之外，最底部有个<code>objc_method</code>的属性，这个结构体就是用来定义方法的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_method &#123;</div><div class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</div><div class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</div><div class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>里面有三个属性，SEL、方法类型和IMP。最重要的两个SEL和IMP，一个是查找方法的，另一个是实现方法的。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>我们先来看下<code>SEL</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure>
<p>在Objective-C的编译过程中，会根据每一个方法的名字、参数序列来生成一个唯一的整型标示，这个标示就是SEL。我们可以用下面的代码获取到SEL，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SEL selector = @selector(eat);  // eat是一个Person类里的方法名</div><div class="line">NSLog(@&quot;SEL: %p&quot;, selector);</div><div class="line"></div><div class="line">// output: SEL: 0x1049748ee</div></pre></td></tr></table></figure>
<p>在Objective-C中，只要两个方法名相同，那么方法的SEL就是一样的。每一个方法对应一个SEL，同一个类中不能存在两个同名的方法，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// Person.h</div><div class="line"></div><div class="line">- (void)showMessage:(NSString *)message;</div><div class="line">- (void)showMessage:(NSDictionary *)message;</div><div class="line"></div><div class="line">//Error: Duplicate declaration of method &apos;showMessage:&apos;</div></pre></td></tr></table></figure>
<p>拥有两个同名的方法，Xcode就会提示你重复声明方法而报错，但是，在不同类中使用同名的方法是不会报错的，并且其SEL也是一样的。</p>
<p>有关SEL的更多介绍，希望放到消息发送那块去讲，了解这些基础就可以了。</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP叫做函数指针，指的是方法实现的首地址。前面说了，查找方法通过SEL去查找对应的IMP，获取到IMP后，我们就获取到了方法实现的首地址了，也就是执行方法的入口，这样，我们就可以像调用C语言函数一样，去调用Objective-C的方法了。</p>
<p>SEL和IMP说完之后，我们回到Method上，Method结构体中包含一个SEL和IMP，相当于在SEL和IMP之间作了一个映射。每个方法都有自己的唯一标示和方法地址，执行起来效率最高。具体细节到消息发送那块去讲。</p>
<h3 id="方法缓存"><a href="#方法缓存" class="headerlink" title="方法缓存"></a>方法缓存</h3><p>在Class的定义中，有一行是关于方法缓存的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存</div></pre></td></tr></table></figure>
<p>打开<code>objc_cache</code>，我们可以看到其结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_cache &#123;</div><div class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</div><div class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</div><div class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每个类只有一份方法缓存，当第一次方法被调用之后，再次调用的时候，就会优先从缓存列表中查找，如果没有的话，才会从methodLists中查找。</p>
<h3 id="协议列表"><a href="#协议列表" class="headerlink" title="协议列表"></a>协议列表</h3><p>Class定义中还有一个协议列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表</div></pre></td></tr></table></figure>
<p>查看<code>objc_protocol_list</code>，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">struct objc_protocol_list &#123;</div><div class="line">    struct objc_protocol_list *next;</div><div class="line">    long count;</div><div class="line">    __unsafe_unretained Protocol *list[1];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>顾名思义，其中包含了该Class的所有协议列表。我们可以使用<code>class_copyProtocolList</code>获取所有的<code>Protocol</code>。</p>
<h3 id="静态调用和动态调用"><a href="#静态调用和动态调用" class="headerlink" title="静态调用和动态调用"></a>静态调用和动态调用</h3><p>在说Objective-C的消息机制之前，我们先来看下在C中是如何进行函数调用的，在C语言中，函数调用属于静态绑定，意思就是在编译期间就可以获取到函数调用指令，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;eat\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void rest() &#123;</div><div class="line">    printf(&quot;rest\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doSomeThing(int type) &#123;</div><div class="line">    if (type == 0) &#123;</div><div class="line">        eat();</div><div class="line">    &#125;else &#123;</div><div class="line">        rest();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    doSomeThing(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种函数调用，在编译期间就可以确定函数调用指令，所以为静态调用，下面我们换一种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">void eat() &#123;</div><div class="line">    printf(&quot;eat\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void rest() &#123;</div><div class="line">    printf(&quot;rest\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void doSomeThing(int type) &#123;</div><div class="line">    void (*method)();</div><div class="line">    if (type == 0) &#123;</div><div class="line">        method = eat;</div><div class="line">    &#125;else &#123;</div><div class="line">        method = rest;</div><div class="line">    &#125;</div><div class="line">    method();</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line"></div><div class="line">    doSomeThing(1);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二个和第一个区别在于，第二个只有在运行的时候，才会知道method方法到底指的是哪个，这就使用到了简单的动态调用了，因为需要在运行的时候才会知道method函数调用指令。</p>
<p>在Objective-C中，所有的函数调用，我们叫做发送消息，所谓的发送消息，就是指使用动态绑定技术在运行时决定需要调用的函数指令。所以我们经常说Objective-C是一门动态语言。</p>
<h3 id="objc-msgSend-消息分发"><a href="#objc-msgSend-消息分发" class="headerlink" title="objc_msgSend(消息分发)"></a>objc_msgSend(消息分发)</h3><p>当我们使用Objective-C进行方法调用时，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[person doSomething];</div></pre></td></tr></table></figure>
<p>通俗地讲，我们使用面向对象的思维去解释的话，是<code>person</code>对象调用<code>doSomething</code>方法。但是如果从runtime的角度去看，其实是一个函数调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">objc_msgSend(person,doSomething);</div></pre></td></tr></table></figure>
<p>通俗地讲，就是在Objective-C中，我们进行方法调用的时候，其实是runtime使用<code>objc_msgSend</code>帮助我们发送一个消息，来帮助我们需要调用的方法。</p>
<p>然后，<code>objc_msgSend</code>会负责分发这个消息，它会查找合适的函数指针或者IMP，然后调用该函数，任何通过<code>objc_msgSend</code>传递的参数，最终都会变成IMP的参数。<code>objc_msgSend</code>的职责范围是接收参数，然后找到函数指针，进行分发。就像一个快递员一样，根据快递单号和地址，将快递从一个地方送到另外一个地方。</p>
<p>当然，为了提升速度，runtime还提供了方法缓存来加快查找速度。</p>
<p>我们把流程总结一下：</p>
<ol>
<li>[person doSomething];</li>
<li>objc_msgSend(person,@selector(doSomething));</li>
<li>objc_msgSend会进行消息分发，先是从cache中去查找，cache是一个hash表，Selector是key；</li>
<li>如果cache中没有找到，那么再去methodLists去找，如果找到，就会把它放到缓存中去，下次就不用直接查表了;</li>
<li>如果在methodLists中都没找到，那么会去superClass中去找，直到最顶端的根类；</li>
<li>如果到根类都没有找到的话，那么就会报<code>unrecognized selector sent to instance 0x7fe672452350</code>这个异常。</li>
</ol>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><p>上面，我们看到，如果找不到的话，就会报异常，<code>unrecognized selector sent to instance 0x7fe672452350</code>，在这个异常抛出之前，会试图通过三种途径来拯救异常。</p>
<ol>
<li>Method resolution</li>
<li>Fast forwarding</li>
<li>Normal forwarding</li>
</ol>
<h4 id="Method-resolution"><a href="#Method-resolution" class="headerlink" title="Method resolution"></a>Method resolution</h4><p>Method resolution提供了两个方法，一个是<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>，另一个是<code>+ (BOOL)resolveClassMethod:(SEL)sel</code>。从名字可以看出，一个是用于实例方法，一个用于类方法。都是一样的，我们以上面的[person doSomething]为类，来重写<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code>来保证运行不崩溃。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">void testMethod(id obj, SEL _cmd) &#123;</div><div class="line">    NSLog(@&quot;testMethod防止程序崩溃&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</div><div class="line">    if (sel == @selector(doSomething)) &#123;</div><div class="line">        class_addMethod([self class], sel, (IMP)testMethod, &quot;v@:&quot;);</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return [super resolveInstanceMethod:sel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序之后，会发现没有抛出异常，而是打印出了<code>testMethod防止程序崩溃</code>的信息。</p>
<h4 id="Fast-forwarding"><a href="#Fast-forwarding" class="headerlink" title="Fast forwarding"></a>Fast forwarding</h4><p>在使用之前，，我们先给测试类新加一个方法，来创造下测试条件，在头文件中加上下面这句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)hasPrefix:(NSString *)str;</div></pre></td></tr></table></figure>
<p>实现文件里什么都不写，运行之后会发现直接报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;-[MessageSendTest hasPrefix:]: unrecognized selector sent to instance 0x60800000ccf0&apos;</div></pre></td></tr></table></figure>
<p>好了，我们看下如何使用Fast forwarding来保证异常不会发生。我们在测试类中重写以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</div><div class="line">    if (aSelector == @selector(hasPrefix:)) &#123;</div><div class="line">        return [NSString string];</div><div class="line">    &#125;</div><div class="line">    return [super forwardingTargetForSelector:aSelector];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现，在该方法中，我们让如果请求的是<code>hasPrefix:</code>，直接返回<code>[NSString string]</code>，将这个消息转发给了NSString对象，我们知道，<code>hasPrefix:</code>是NSString的系统方法，肯定有实现的，所以再次运行程序之后，没有崩溃。</p>
<h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>Normal forwarding一般是最后救命的稻草了。这些可以在<code>-forwardInvocation:</code>中实现，我们还是用上面的例子。</p>
<p>我们先定义一个全局的NSString变量，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString _string = [NSString string];</div></pre></td></tr></table></figure>
<p>下面是关键实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</div><div class="line">    SEL sel = anInvocation.selector;</div><div class="line"></div><div class="line">    if ([_string respondsToSelector:sel]) &#123;</div><div class="line">        [anInvocation invokeWithTarget:_string];</div><div class="line">    &#125;else &#123;</div><div class="line">        [self doesNotRecognizeSelector:sel];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</div><div class="line">    NSMethodSignature *signature = [super methodSignatureForSelector:aSelector];</div><div class="line">    if (!signature) &#123;</div><div class="line">        signature = [_string methodSignatureForSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">    return signature;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里代码也是比较好理解的，调用一个方法，首先会走<code>methodSignatureForSelector</code>这个方法，如果发现方法签名是nil，我们加了个判断，如果是nil，则走NSString实例的方法签名。</p>
<p>重签名之后，会走<code>forwardInvocation</code>来进行分发，我们这里增加了一个判断，如果在NSString中找到该SEL，那么就直接在新的对象上执行该SEL，否则执行<code>doesNotRecognizeSelector</code>方法。这样就可以完全避免<code>unrecognized selector sent to instance</code>崩溃问题。</p>
<p>另外，如果关注过JSPatch的同学，可以看到JSPatch作者解决参数获取的问题时，就用了这个技术，详情可以查看Bang的博客, 在文末那里可以找到。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html</a></p>
<p><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Objective-C&quot;&gt;&lt;a href=&quot;#Objective-C&quot; class=&quot;headerlink&quot; title=&quot;Objective-C&quot;&gt;&lt;/a&gt;Objective-C&lt;/h3&gt;&lt;p&gt;面向对象的语言有很多种，比如Java、C++和Objective-C。但是面向对象的语言分两种，一种是函数调用型，另一种是消息结构型。其中Java和C++属于函数调用型，而OC属于消息结构型。为了支持消息结构，OC和其他语言不同的是，不仅仅只有一个编译器，还存在一个叫做runtime组件的东西，它的出现目的是简化编译器的功能，在OC中，基本的重要功能都是runtime组件完成的，所有的内存管理方法，对象所需的数据结构和方法都在其中。&lt;/p&gt;
&lt;p&gt;这么一来，我们只需要更新runtime组件，就可以达到修改应用功能，我们使用的JSPatch、Aspects就是利用了这一功能。如果要在函数调用型语言上完成这些事，由于这些工作是在编译期完成的，所以必须重新编译代码才能完成。&lt;/p&gt;
&lt;p&gt;在我们平时编写OC代码时，其实已经有意无意在和runtime打交道了，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平时写的类和方法，并且使用它们，其实runtime已经在悄悄地给我们提供支持；&lt;/li&gt;
&lt;li&gt;当我们使用到&lt;code&gt;isKindOfClass&lt;/code&gt;、&lt;code&gt;isMemberOfClass&lt;/code&gt;、&lt;code&gt;conformsToProtocol&lt;/code&gt;和&lt;code&gt;respondsToSelector&lt;/code&gt;这些方法时，其实就是在调底层runtime的API；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;对象模型&quot;&gt;&lt;a href=&quot;#对象模型&quot; class=&quot;headerlink&quot; title=&quot;对象模型&quot;&gt;&lt;/a&gt;对象模型&lt;/h3&gt;&lt;p&gt;Objective-C类是用Class类型表示的，实际上是一个指向&lt;code&gt;objc_class&lt;/code&gt;结构体的指针。打开&lt;code&gt;objc.h&lt;/code&gt;即可看到：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;typedef struct objc_class *Class;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;点进&lt;code&gt;objc_class&lt;/code&gt;，可以看到该结构体定义：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;struct objc_class &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Class isa  OBJC_ISA_AVAILABILITY;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#if !__OBJC2__&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Class super_class                                        OBJC2_UNAVAILABLE;     // 父类&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    const char *name                                         OBJC2_UNAVAILABLE;     // 类名&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    long version                                             OBJC2_UNAVAILABLE;     // 类的版本信息，默认为0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    long info                                                OBJC2_UNAVAILABLE;     // 类信息，提供运行时使用一些标示位&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    long instance_size                                       OBJC2_UNAVAILABLE;     // 类的实例变量大小&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;     // 类的成员变量列表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;     // 类的方法列表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;     // 类的方法缓存&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;     // 类的协议列表&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;#endif&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125; OBJC2_UNAVAILABLE;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_apply总结</title>
    <link href="http://yoursite.com/2016/07/21/dispatch-apply%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/07/21/dispatch-apply总结/</id>
    <published>2016-07-21T15:44:56.000Z</published>
    <updated>2017-07-29T00:48:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="dispatch-apply的基本用法"><a href="#dispatch-apply的基本用法" class="headerlink" title="dispatch_apply的基本用法"></a>dispatch_apply的基本用法</h4><p>dispatch_apply的作用是按照指定的次数将指定的Block追加到指定的Dispatch Queue中,并等到全部的处理执行结束。表面上看其实就是在一个队列上运行多次Block。对于一些开发场景，非常适合使用dispatch_apply来做。</p>
<h4 id="实现遍历"><a href="#实现遍历" class="headerlink" title="实现遍历"></a>实现遍历</h4><p>好吧，这个大家都是知道的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;, @&quot;h&quot;, @&quot;i&quot;, @&quot;j&quot;];</div><div class="line">//2.创建一个全局队列</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">//3.通过dispatch_apply函数对NSArray中的全部元素进行处理,并等待处理完成,</div><div class="line">dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">    NSLog(@&quot;%zu: %@, currentThread: %@&quot;, index, [array objectAtIndex:index], [NSThread currentThread]);</div><div class="line">  &#125;);</div><div class="line">NSLog(@&quot;done. currentThread: %@&quot;, [NSThread currentThread]);</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">1: b, currentThread: &lt;NSThread: 0x608000070740&gt;&#123;number = 10, name = (null)&#125;</div><div class="line">2: c, currentThread: &lt;NSThread: 0x60800007fac0&gt;&#123;number = 11, name = (null)&#125;</div><div class="line">3: d, currentThread: &lt;NSThread: 0x60800007f700&gt;&#123;number = 12, name = (null)&#125;</div><div class="line">4: e, currentThread: &lt;NSThread: 0x6000000705c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">5: f, currentThread: &lt;NSThread: 0x608000070740&gt;&#123;number = 10, name = (null)&#125;</div><div class="line">6: g, currentThread: &lt;NSThread: 0x60800007fac0&gt;&#123;number = 11, name = (null)&#125;</div><div class="line">7: h, currentThread: &lt;NSThread: 0x60800007f700&gt;&#123;number = 12, name = (null)&#125;</div><div class="line">8: i, currentThread: &lt;NSThread: 0x6000000705c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">9: j, currentThread: &lt;NSThread: 0x608000070740&gt;&#123;number = 10, name = (null)&#125;</div><div class="line">done. currentThread: &lt;NSThread: 0x6000000705c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>可以实现遍历功能，但是需要注意的是，使用dispatch_apply会堵塞线程的，所以会看到done在最后才会被打印，这里是关键。所以使用dispatch_apply可以实现一些dispatch_sync效果。</p>
<h4 id="dispatch-async和dispatch-apply结合使用"><a href="#dispatch-async和dispatch-apply结合使用" class="headerlink" title="dispatch_async和dispatch_apply结合使用"></a>dispatch_async和dispatch_apply结合使用</h4><p>先贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;, @&quot;h&quot;, @&quot;i&quot;, @&quot;j&quot;];</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">        NSLog(@&quot;%zu: %@, currentThread: %@&quot;, index, [array objectAtIndex:index], [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;回到主线程执行用户界面更新等操作. currentThread: %@&quot;, [NSThread currentThread]);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 打印结果</div><div class="line">0: a, currentThread: &lt;NSThread: 0x600000260fc0&gt;&#123;number = 13, name = (null)&#125;</div><div class="line">1: b, currentThread: &lt;NSThread: 0x60800007f0c0&gt;&#123;number = 14, name = (null)&#125;</div><div class="line">2: c, currentThread: &lt;NSThread: 0x60800006fcc0&gt;&#123;number = 15, name = (null)&#125;</div><div class="line">3: d, currentThread: &lt;NSThread: 0x60800007f300&gt;&#123;number = 16, name = (null)&#125;</div><div class="line">4: e, currentThread: &lt;NSThread: 0x600000260fc0&gt;&#123;number = 13, name = (null)&#125;</div><div class="line">5: f, currentThread: &lt;NSThread: 0x60800007f0c0&gt;&#123;number = 14, name = (null)&#125;</div><div class="line">6: g, currentThread: &lt;NSThread: 0x60800006fcc0&gt;&#123;number = 15, name = (null)&#125;</div><div class="line">7: h, currentThread: &lt;NSThread: 0x60800007f300&gt;&#123;number = 16, name = (null)&#125;</div><div class="line">8: i, currentThread: &lt;NSThread: 0x600000260fc0&gt;&#123;number = 13, name = (null)&#125;</div><div class="line">9: j, currentThread: &lt;NSThread: 0x60800007f0c0&gt;&#123;number = 14, name = (null)&#125;</div><div class="line">回到主线程执行用户界面更新等操作. currentThread: &lt;NSThread: 0x6000000705c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>在日常开发工作中，我们可能会遇到需要操作多个任务后，然后回调到主线程进行页面刷新。当然，我们也可以使用dispatch_group来实现，但是如果多个任务都是十分相似的，这个时候可以推荐使用dispatch_apply来做（不强求）。</p>
<h4 id="dispatch-apply注意点"><a href="#dispatch-apply注意点" class="headerlink" title="dispatch_apply注意点"></a>dispatch_apply注意点</h4><p>dispatch_apply十分便利，但是需要注意的是dispatch_apply在执行Block的时候，会堵塞线程的，这块需要注意一下，其他的也没什么了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;dispatch-apply的基本用法&quot;&gt;&lt;a href=&quot;#dispatch-apply的基本用法&quot; class=&quot;headerlink&quot; title=&quot;dispatch_apply的基本用法&quot;&gt;&lt;/a&gt;dispatch_apply的基本用法&lt;/h4&gt;&lt;p&gt;di
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习之闭包</title>
    <link href="http://yoursite.com/2016/04/21/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2016/04/21/Swift学习之闭包/</id>
    <published>2016-04-21T02:03:15.000Z</published>
    <updated>2017-07-12T08:51:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>作为一门现代编程语言，Swift对函数式编程范式有着良好的支持，而函数式编程又和闭包有着紧密的关系，今天我们就学习下闭包这个概念。</p>
</blockquote>
<p>闭包的出现，可能会打破脑海中存在已久的函数概念，</p>
<p>一般来说，一个函数只会有一个实例，而闭包的出现，使得函数可以有多个实例。当然，函数得处于其相关的上下文环境中。闭包这个概念，在OC/C中叫做Blocks，用过的人都知道，好难理解Blocks这东西到底是干嘛的，十分晦涩。原因在于，不管是OC或者是Java，都是一门面向对象语言，由于面向对象语言本身对函数具有局限性，闭包的实现，是迫于编程语言的发展趋势而添加的特性，光看代码，就感觉好像一个补丁。  </p>
<p>在说闭包之前，需要先谈谈“自由变量”这个概念，那么什么是自由变量呢？</p>
<blockquote>
<p>本意应该是在一个作用域中，如果使用未在本作用域中声明的变量，那么对于此作用域，该变量就是一个自由变量。</p>
</blockquote>
<p>而闭包，就是一个引用了自由变量的函数，自由变量将和函数一同存在。  </p>
<p>在谈谈“高阶函数”，什么是高阶函数？</p>
<blockquote>
<p>高阶函数就是接受一个或者多个函数当作参数，并且返回值也是个函数的函数。</p>
</blockquote>
<p>在命令式的编程语言中，对函数的看法往往比较局限，认为函数就是一系列语句的集合。而在函数式编程语言中，函数是十分灵活的，这就使得在Swift中闭包变得十分简单，在Swift中，函数都是高阶函数，而高阶函数需要函数先成为闭包，下面给个简单的高阶函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">func makeCounter() -&gt; (() -&gt; Int) &#123;</div><div class="line">    var count = 0</div><div class="line"></div><div class="line">    func add() -&gt; Int &#123;</div><div class="line">        count += 1</div><div class="line">        return count</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return add</div><div class="line">&#125;</div><div class="line"></div><div class="line">let add = makeCounter()</div><div class="line">add()		//1</div><div class="line">add()		//2</div></pre></td></tr></table></figure>
<p>例子是实现一个自增的高阶函数，我们可以看出，<code>makeCounter</code>返回的并不是一个数据值，而是一个函数。当我们在全局中获取到<code>makeCounter</code>的返回函数后，每执行一次，都会进行加一操作，说明虽然我们离开了<code>count</code>的作用域，但还是可以使用<code>count</code>的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let add2 = makeCounter()</div><div class="line">add2()		//1</div><div class="line">add2()		//2</div></pre></td></tr></table></figure>
<p>我们再来获取一个函数返回值，会发现，输出结果依然是1、2。这说明，此函数可以有多个实例，它们有着自己的count值，之间并不共享。  </p>
<a id="more"></a>
<p>但是，对象和闭包还是有区别的。对象是一种数据，它有着属性和行为，而闭包，可以称它是一种行为，和对象的行为所不同的是，它是附有数据的，它可以获取到自由变量。在函数式编程中，如果函数是闭包的，那么它就有了和对象同等的地位，一般来说，通常把这种地位叫做“一等函数”。  </p>
<p>以前了解过Blocks的话，会时不时听到匿名函数这个概念。那什么是匿名函数呢？就拿上面的例子来说，细心的会不会发现，<code>makeCounter</code>里面的<code>add</code>这个内部函数除了被返回，并没有什么卵用。其实根本就不需要名字，可以被定义成一个匿名函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">func makeCounter2() -&gt; (() -&gt; Int) &#123;</div><div class="line">    var count = 0</div><div class="line">    return&#123;() -&gt; Int in</div><div class="line">        count += 1</div><div class="line">        return count</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用闭包，可以使编程模块化，我们可以将一些小的模块使用闭包完成，提高开发速度和程序的复用性。另外，使用闭包可以简化代码，用过GCD＋Blocks的人应该都理解，闭包可以让处理问题变的比较方便，代码量也会少很多，用好了受益无穷！  </p>
<blockquote>
<p>总之一句话，代码写的更优雅了  ^()^</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;作为一门现代编程语言，Swift对函数式编程范式有着良好的支持，而函数式编程又和闭包有着紧密的关系，今天我们就学习下闭包这个概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;闭包的出现，可能会打破脑海中存在已久的函数概念，&lt;/p&gt;
&lt;p&gt;一般来说，一个函数只会有一个实例，而闭包的出现，使得函数可以有多个实例。当然，函数得处于其相关的上下文环境中。闭包这个概念，在OC/C中叫做Blocks，用过的人都知道，好难理解Blocks这东西到底是干嘛的，十分晦涩。原因在于，不管是OC或者是Java，都是一门面向对象语言，由于面向对象语言本身对函数具有局限性，闭包的实现，是迫于编程语言的发展趋势而添加的特性，光看代码，就感觉好像一个补丁。  &lt;/p&gt;
&lt;p&gt;在说闭包之前，需要先谈谈“自由变量”这个概念，那么什么是自由变量呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本意应该是在一个作用域中，如果使用未在本作用域中声明的变量，那么对于此作用域，该变量就是一个自由变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而闭包，就是一个引用了自由变量的函数，自由变量将和函数一同存在。  &lt;/p&gt;
&lt;p&gt;在谈谈“高阶函数”，什么是高阶函数？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;高阶函数就是接受一个或者多个函数当作参数，并且返回值也是个函数的函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在命令式的编程语言中，对函数的看法往往比较局限，认为函数就是一系列语句的集合。而在函数式编程语言中，函数是十分灵活的，这就使得在Swift中闭包变得十分简单，在Swift中，函数都是高阶函数，而高阶函数需要函数先成为闭包，下面给个简单的高阶函数的例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;func makeCounter() -&amp;gt; (() -&amp;gt; Int) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    var count = 0&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    func add() -&amp;gt; Int &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        count += 1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        return count&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return add&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let add = makeCounter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add()		//1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add()		//2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;例子是实现一个自增的高阶函数，我们可以看出，&lt;code&gt;makeCounter&lt;/code&gt;返回的并不是一个数据值，而是一个函数。当我们在全局中获取到&lt;code&gt;makeCounter&lt;/code&gt;的返回函数后，每执行一次，都会进行加一操作，说明虽然我们离开了&lt;code&gt;count&lt;/code&gt;的作用域，但还是可以使用&lt;code&gt;count&lt;/code&gt;的值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let add2 = makeCounter()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add2()		//1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;add2()		//2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们再来获取一个函数返回值，会发现，输出结果依然是1、2。这说明，此函数可以有多个实例，它们有着自己的count值，之间并不共享。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift之自动引用计数</title>
    <link href="http://yoursite.com/2016/04/05/Swift%E4%B9%8B%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
    <id>http://yoursite.com/2016/04/05/Swift之自动引用计数/</id>
    <published>2016-04-05T08:04:27.000Z</published>
    <updated>2017-07-12T08:49:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  </p>
</blockquote>
<p>在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  </p>
<p>特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  </p>
<h3 id="自动引用计数原理"><a href="#自动引用计数原理" class="headerlink" title="自动引用计数原理"></a>自动引用计数原理</h3><p>首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  </p>
<p>为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  </p>
<p>下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Person类很简单，有一个名为name的属性，然后重写<code>init</code>和<code>deinit</code>方法。然后我们定义三个变量来对Person类进行引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person1: Person?</div><div class="line">var person2: Person?</div><div class="line">var person3: Person?</div></pre></td></tr></table></figure>
<p>可选选项可以保证在没实例化之前是nil。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1 = Person(name: &quot;Jack&quot;)</div><div class="line">person2 = person1</div><div class="line">person3 = person1</div></pre></td></tr></table></figure>
<p>当我们对person1执行实例化时，会打印出<code>Jack正在被初始化</code>，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  </p>
<p>接下来我们通过赋值<code>nil</code>来断开强引用关系。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1 = nil</div><div class="line">person2 = nil</div></pre></td></tr></table></figure>
<p>然后我们断开person3的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person3 = nil</div></pre></td></tr></table></figure>
<p>这时我们发现，Console中打印出了<code>Jack正在被销毁</code>的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。</p>
<a id="more"></a>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>这个问题发生的原因很简单，就是使用ARC的话，我们会发现有时候引用计数永远也不会为0，两个类之间互相持有对方的强引用，这就是所谓的循环强引用问题。  </p>
<p>我们先来看看强引用是怎么产生的，首先定义两个类，Person和Apartment，代表人和公寓两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line">    var apartment: Apartment?</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之所以要将变量定义成可选的，是因为不是每个人都有公寓的，类似的，不是每个公寓都有人住，所以符合现实需求。  </p>
<p>然后我们定义两个变量，分别对Person和Apartment的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var per: Person?</div><div class="line">var apart: Apartment?</div><div class="line"></div><div class="line">per = Person(name: &quot;Jack&quot;)</div><div class="line">apart = Apartment(unit: &quot;4A&quot;)</div></pre></td></tr></table></figure>
<p>注意，对于对象的引用为强引用。但是如何实现人住进公寓，公寓里有人呢，来看看实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per!.apartment = apart</div><div class="line">apart!.person = per</div></pre></td></tr></table></figure>
<p>现在，实现了上面所说的功能，但是不幸的是，这里会造成一个循环引用，Person实例有一个指向Apartment实例的引用，而Apartment实例有一个指向Person实例的引用。这时，像上面的处理一样，我们把变量设为<code>nil</code>。看会不会销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有打印销毁log，说明Person和Apartment实例之间的强引用保留了下来并不会断开。这就是我们常说的循环引用。</p>
<h3 id="循环引用解决办法"><a href="#循环引用解决办法" class="headerlink" title="循环引用解决办法"></a>循环引用解决办法</h3><p>以前在Objective-C中，如果出现了循环引用，那么使用<code>weak</code>可以解决问题，那在Swift中一样，只不过在Swift中有两种解决办法，一种是weak，另外一种是unowned。  </p>
<p>两者的解决办法都相似，就是允许一个实例引用另外一个实例但不保持强引用。  </p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>和强引用对比，弱引用不会对其引用的实例保持强引用，这一特性阻止了变成循环强引用的端倪。  </p>
<p>弱引用必须被声明为变量，而且可以没有值，我们还是依照上面的那个例子，但是这次Apartment类有些改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    weak var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将person设为weak类型，然后将变量指向nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们会发现，这次执行了销毁方法，打印出了log，说明循环引用被我们打破了。  </p>
<h4 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h4><p>和弱引用不同的是，弱引用是没有值时也可以用，无主引用时要保证总是有值。因此，无主引用一般总是被定义为非可选类型。判断到底是用弱引用还是无主引用，只要根据该引用是可选类型的还是非可选类型的。</p>
<h3 id="闭包引起的循环引用"><a href="#闭包引起的循环引用" class="headerlink" title="闭包引起的循环引用"></a>闭包引起的循环引用</h3><p>在真实的开发中，很多循环引用都发生在此，那么为什么会发生呢？我们以一个例子作为参考，先实现一个简单的HTML类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，类中包括一个闭包，是根据属性值来返回不同的数据。然后我们实现一个变量来引用 <code>HTMLElement</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello world&quot;)</div><div class="line">print(paragraph!.asHTML())</div></pre></td></tr></table></figure>
<p>可以看到，屏幕上打印出了<code>&lt;p&gt;hello world&lt;/p&gt;</code>字样，然后我们对变量赋值<code>nil</code>，取消引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paragraph = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有调用类的销毁方法，说明出现了循环引用。那么此处的循环引用是怎么出现的呢？  </p>
<p>首先说明，出现强引用的是闭包和引用实例两者，闭包其实和类相似，都是引用类型。实例<code>paragraph</code>持有闭包的引用，而闭包中又使用了<code>self</code>，因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用，这样两个对象就产生了循环强引用。</p>
<h3 id="解决闭包引起的循环引用"><a href="#解决闭包引起的循环引用" class="headerlink" title="解决闭包引起的循环引用"></a>解决闭包引起的循环引用</h3><p>那么如何解决呢？在Objective-C中，解决办法是外部将<code>self</code>设为<code>weak</code>类型，从而保证闭包内捕获<code>self</code>时不会发生强引用。那么在Swift中，解决的办法也类似。  </p>
<p>只不过分为弱引用和无主引用两种，和上面类似，弱引用是针对可选类型的，而无主引用是针对非可选类型的。在这个例子中，使用无主引用比较恰当。我们修改<code>HTMLElement</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        [unowned self] in</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了不发生循环引用，我们在闭包中使用无主引用来捕获<code>self</code>，这样将实例设为<code>nil</code>，我们发现屏幕上打印出了<code>HTMLElement对象被销毁</code>。说明我们解决问题了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  &lt;/p&gt;
&lt;p&gt;特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  &lt;/p&gt;
&lt;h3 id=&quot;自动引用计数原理&quot;&gt;&lt;a href=&quot;#自动引用计数原理&quot; class=&quot;headerlink&quot; title=&quot;自动引用计数原理&quot;&gt;&lt;/a&gt;自动引用计数原理&lt;/h3&gt;&lt;p&gt;首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  &lt;/p&gt;
&lt;p&gt;为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  &lt;/p&gt;
&lt;p&gt;下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;class Person &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    let name: String&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    init(name: String) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        self.name = name&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&amp;quot;\(name)正在被初始化&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    deinit &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        print(&amp;quot;\(name)正在被销毁&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Person类很简单，有一个名为name的属性，然后重写&lt;code&gt;init&lt;/code&gt;和&lt;code&gt;deinit&lt;/code&gt;方法。然后我们定义三个变量来对Person类进行引用：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var person1: Person?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var person2: Person?&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var person3: Person?&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可选选项可以保证在没实例化之前是nil。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person1 = Person(name: &amp;quot;Jack&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person2 = person1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person3 = person1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们对person1执行实例化时，会打印出&lt;code&gt;Jack正在被初始化&lt;/code&gt;，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  &lt;/p&gt;
&lt;p&gt;接下来我们通过赋值&lt;code&gt;nil&lt;/code&gt;来断开强引用关系。  &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person1 = nil&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;person2 = nil&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后我们断开person3的强引用。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;person3 = nil&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这时我们发现，Console中打印出了&lt;code&gt;Jack正在被销毁&lt;/code&gt;的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift学习之枚举、类和结构体</title>
    <link href="http://yoursite.com/2016/03/24/Swift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%9E%9A%E4%B8%BE%E3%80%81%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2016/03/24/Swift学习之枚举、类和结构体/</id>
    <published>2016-03-24T00:58:55.000Z</published>
    <updated>2017-07-12T08:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><blockquote>
<p>枚举是为一组相关的值定义了一个共同的类型。</p>
</blockquote>
<p>下面使用枚举表示水果的颜色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum FruitsColor &#123;</div><div class="line">	case Red</div><div class="line">	case Yellow</div><div class="line">	case Green</div><div class="line">	case White</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果枚举成员没有设置原始值，其原始值将为0，依次递增1。当然，多个成员值可以出现在同一行上，用逗号隔开：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">enum FruitColor &#123;</div><div class="line">    case Red, Green, Yellow, White</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Swift中，使用Switch可以匹配枚举值，这十分方便。我们举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let condition: FruitColor = .Red</div><div class="line">switch condition &#123;</div><div class="line">case .Red:</div><div class="line">    print(&quot;Red&quot;)</div><div class="line">case .Green:</div><div class="line">    print(&quot;Green&quot;)</div><div class="line">case .Yellow:</div><div class="line">    print(&quot;Yellow&quot;)</div><div class="line">default:</div><div class="line">    print(&quot;default&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>出了匹配，枚举还可以进行关联值操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum FruitProperty &#123;</div><div class="line">	case Name(String)</div><div class="line">	case Color(String)</div><div class="line">&#125;</div><div class="line"></div><div class="line">var fruit = FruitProperty(&quot;Apple&quot;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="类和结构体"><a href="#类和结构体" class="headerlink" title="类和结构体"></a>类和结构体</h3><p>在Swift中，类和结构体有很多相似之处。包括：</p>
<blockquote>
<ol>
<li>都具有属性用于存储值；</li>
<li>都提供方法实现功能；</li>
<li>都提供附属脚本用于访问值；</li>
<li>都提供构造器生成初始化值；</li>
<li>都提供扩展增加默认实现的方法；</li>
<li>都提供协议实现某种标准功能。</li>
</ol>
</blockquote>
<p>但是，类和结构体还是有些区别，比如：</p>
<blockquote>
<ol>
<li>类是允许一个类继承另一个类的特征；</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型；</li>
<li>解构器允许一个类实例释放任何其所被分配的资源；</li>
<li>引用计数允许对一个类的多次引用。</li>
</ol>
</blockquote>
<p>特别注意，在结构体中，是通过被复制的方式在代码中传递的，而不是使用引用计数。  </p>
<p>语法上，两者很像。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class FruitClass &#123;</div><div class="line">    var fruitName: String?</div><div class="line">    var fruitColor: String?</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct FruitStruct &#123;</div><div class="line">    var fruitName: String</div><div class="line">    var fruitColor: String</div><div class="line">&#125;</div><div class="line"></div><div class="line">let fruit = FruitClass()</div><div class="line">let fruit02 = FruitStruct(fruitName: &quot;Orange&quot;, fruitColor: &quot;Yellow&quot;)</div></pre></td></tr></table></figure>
<h4 id="有关类是引用类型的解释"><a href="#有关类是引用类型的解释" class="headerlink" title="有关类是引用类型的解释"></a>有关类是引用类型的解释</h4><p>和数值的类型不同，当类被赋予到一个变量、常量或者被传递到一个函数中时，其值不会被拷贝。引用的是已存在的实例本身而不是拷贝。  </p>
<p>我们以代码来解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let fruit = FruitClass()</div><div class="line">fruit.fruitColor = &quot;Yellow&quot;</div><div class="line">fruit.fruitName = &quot;Orange&quot;</div><div class="line"></div><div class="line">let fruit02 = fruit</div><div class="line">fruit02.fruitName = &quot;Apple&quot;</div><div class="line">print(fruit.fruitName)		//Apple</div><div class="line">print(fruit02.fruitName)	//Apple</div></pre></td></tr></table></figure>
<p>由于类是引用类型，<code>fruit</code>和<code>fruit02</code>实际上引用的是FruitClass实例，它们是同一实例的两种叫法，注意，<code>fruit</code>和<code>fruit02</code>都被声明为常量而非变量，你依然可以改变color和name两个属性，是因为它们俩并不“存储”<code>FruitClass</code>实例，而只是对实例的引用。所以，改变的是被引用实例的属性值，而不是引用实例常量的值。  </p>
<p>如果判断两个常量是否引用于同一个实例，利用恒等运算符可以实现。  </p>
<blockquote>
<ul>
<li>等价于 (<code>===</code>)</li>
<li>不等价于 (<code>!==</code>)</li>
</ul>
</blockquote>
<h4 id="有关拷贝和引用"><a href="#有关拷贝和引用" class="headerlink" title="有关拷贝和引用"></a>有关拷贝和引用</h4><p>在Swift中，例如<code>String</code>、<code>Array</code>和<code>Dictionary</code>都是以结构体的形式来实现，这意味着，当发生赋值和函数穿参时，它们的值会被拷贝。  </p>
<p>而在Objective-C中，<code>NSString</code>、<code>NSArray</code>和<code>NSDictionary</code>均是以类的形式出现，并不是结构体。它们在被赋值和函数穿参时，不会发生值拷贝，而是传递当前实例的引用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;枚举是为一组相关的值定义了一个共同的类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面使用枚举表示水果的颜色：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitsColor &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Red&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Yellow&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Green&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case White&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果枚举成员没有设置原始值，其原始值将为0，依次递增1。当然，多个成员值可以出现在同一行上，用逗号隔开：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitColor &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    case Red, Green, Yellow, White&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Swift中，使用Switch可以匹配枚举值，这十分方便。我们举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let condition: FruitColor = .Red&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;switch condition &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Red:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Red&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Green:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Green&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;case .Yellow:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;Yellow&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;default:&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    print(&amp;quot;default&amp;quot;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;出了匹配，枚举还可以进行关联值操作，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;enum FruitProperty &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Name(String)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	case Color(String)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var fruit = FruitProperty(&amp;quot;Apple&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Hello world, Swift</title>
    <link href="http://yoursite.com/2016/03/08/Hello-world-Swift/"/>
    <id>http://yoursite.com/2016/03/08/Hello-world-Swift/</id>
    <published>2016-03-08T06:56:40.000Z</published>
    <updated>2017-07-12T08:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>这是一个充满着变化的世界，所做的每一件事，明天都可能会成为没有价值的历史。学习亦是如此，人生的选择不多。  </p>
</blockquote>
<p>满足当下，并不是一个年轻人该有的心态。拥抱Swift这个想法，其实很早就有了，只是每次都缺乏足够的耐心，最终结果未知。这次，就从一个Hello world开始，坚持下去！</p>
<h4 id="打印Hello-world"><a href="#打印Hello-world" class="headerlink" title="打印Hello world"></a>打印Hello world</h4><p>其实和C语言差不多，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;Hello world&quot;)</div></pre></td></tr></table></figure>
<p>不同的是，作为一门现代编程语言，你不需要书写main方法，因为全局作用域的代码会自动当作程序的入口。还有，你再也不用写那个分号了:)</p>
<h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><p>在Swift中，用<code>let</code>来声明常量，用<code>var</code>来声明变量。怎么样，很简单吧，但是有时候我们需要知道常量或者变量是什么类型的，这时就需要类型标注(type annotation)，比如我们想要定义一个名为name的字符型变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name: String</div></pre></td></tr></table></figure>
<p>冒号的意思是“是…类型”，上面这句话可以理解为“声明一个类型为String，名叫name的变量”。当然，你也可以一行定义多个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var name, address: String</div></pre></td></tr></table></figure>
<p>注意：变量和常量的命名不能包含数学符号，箭头，非法的Unicode码，连线与制表符，也不能以数字开头。   </p>
<p>如果要打印常量或者变量，很简单(Hello world已经给出)，如果想当作占位符的方式打印，使用<code>\()</code>来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;Your name is \(name)&quot;)</div></pre></td></tr></table></figure>
<p>上面会打印出name的值。</p>
<a id="more"></a>
<h4 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h4><p>Swift并不强求在每条语句结束后写<code>;</code>，但是，如果你想在同一行代码里写多条独立的语句，那必须加上<code>;</code>。</p>
<h4 id="元组-tuples"><a href="#元组-tuples" class="headerlink" title="元组(tuples)"></a>元组(tuples)</h4><p>注意，这不是数组，这是Swift独有的数据类型，类似于C语言中的结构体，用来存储一组相关的值。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let personInfo = (0001, &quot;Jack&quot;, 23)</div></pre></td></tr></table></figure>
<p>元组内的值可以是任意类型，并不要求是相同类型。上面是模拟一个人的信息，可以这样获取其中的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The number is \(personInfo.0)&quot;)</div><div class="line">print(&quot;The name is \(personInfo.1)&quot;)</div></pre></td></tr></table></figure>
<p>你还可以给单个元素命名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">let personInfo = (number: 0001, name: &quot;Jack&quot;, age: 23)</div></pre></td></tr></table></figure>
<p>打印时可使用名字进行打印：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(&quot;The number is \(personInfo.number)&quot;)</div><div class="line">print(&quot;The name is \(personInfo.name)&quot;)</div></pre></td></tr></table></figure>
<p>在需要临时组织值时，元组会十分好用，但是如果需要复杂的数据结构，那么还是请使用类或者结构体吧。</p>
<h4 id="可选类型-optionals"><a href="#可选类型-optionals" class="headerlink" title="可选类型(optionals)"></a>可选类型(optionals)</h4><p>貌似其他语言都没有这个概念，如果学过Objective-C的话，都知道一个方法要么返回一个对象，要么返回<code>nil</code>，在OC中<code>nil</code>表示一个缺失的合法对象，然而只对对象起作用，其他免谈，相信很多人都在这块出过错，在非对象的类型中，OC的做法是返回一个特殊值来表示值缺失，如<code>NSNotFound</code>。然而，Swift大大简化了这个操作，可选类型可以表示任意类型的值缺失，而不是单单是对象。  </p>
<p>再说这个<code>nil</code>，Swift中的<code>nil</code>和Objective-C中的<code>nil</code>并不太一样，在OC中，<code>nil</code>是一个指向不存在对象的指针，而在Swift中，<code>nil</code> 不是指针，表示值缺省，是一个确定的值。任何类型的可选状态都可以被设置为<code>nil</code>，由此，<code>nil</code>是不能用于非可选的常量或者变量的。</p>
<p>对于可选类型，在判断是否有值时，使用<code>nil</code>则简单了很多，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if numberStr != nil &#123;</div><div class="line">	print(&quot;Result == \(numberStr!)&quot;)</div><div class="line">&#125;else &#123;</div><div class="line">	print(&quot;Result is nil&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>!</code>叫做强制解析，表示“我就知道它有值，请使用它”。但是，使用<code>!</code>来获取一个不存在的可选值时可能会导致运行错误，所以使用前一定要确定可选值一定是非<code>nil</code>。  </p>
<p>有时候，当一个常量或变量被赋值之后，可以确定一个可选类型总会有值，这时每次都去判断可解析可选值时是非常低效的，所以出现了隐式解析可选类型，使用<code>!</code>来标识。顾名思义，它是一个自动解析的可选类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let str: String! = &quot;haha&quot;</div><div class="line">let implStr: String = str</div></pre></td></tr></table></figure>
<p>使用隐式解析后再也不需要<code>!</code>，但是注意，如果隐式解析可选类型在没有值时强制取值，会在运行时出错。所以，如果一个变量可能会成为<code>nil</code>，请不要使用隐式解析可选类型。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Swift支持大部分标准C语言的运算符，但是作为一门现代编程语言，在某些地方做了优化，下面来说说这些变化。</p>
<h4 id="浮点数求余"><a href="#浮点数求余" class="headerlink" title="浮点数求余"></a>浮点数求余</h4><p>在Swift中，可以对浮点数进行求余计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">8 % 2.5    //0.5</div></pre></td></tr></table></figure>
<h4 id="空合运算符-Nil-Coalescing-Operator"><a href="#空合运算符-Nil-Coalescing-Operator" class="headerlink" title="空合运算符(Nil Coalescing Operator)"></a>空合运算符(Nil Coalescing Operator)</h4><p>空合运算符可以对一个可选类型的变量进行空判断，如果包含一个值就进行解封，否则会返回一个默认值。书写方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a ?? b</div></pre></td></tr></table></figure>
<p>注意，a必须是可选类型的，而且默认值包的类型必须和a保持一致，上面代码其实可以按照一个三目运算式来理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a != nil ? a! : b</div></pre></td></tr></table></figure>
<p>#####闭区间运算符<br>闭区间运算符<code>a...b</code>定义一个包含从<code>a</code>到<code>b</code>(包含<code>a</code>和<code>b</code>)的所有值区间。<code>b</code>必须大于<code>a</code>。在<code>for-in</code>中经常用到:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for index in 1...5 &#123;</div><div class="line">    print(&quot;\(index) = \(index)&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="半开区间运算符"><a href="#半开区间运算符" class="headerlink" title="半开区间运算符"></a>半开区间运算符</h4><p>半开区间运算符和闭区间运算符类似，半开区间<code>a..&lt;b</code>定义一个从<code>a</code>到<code>b</code>但不包括<code>b</code>的区间，在遍历数组中经常用到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let fruits = [&quot;apples&quot;, &quot;bananas&quot;, &quot;oranges&quot;]</div><div class="line">for i in 0..&lt;fruits.count &#123;</div><div class="line">    print(fruits[i])</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串和集合类型"><a href="#字符串和集合类型" class="headerlink" title="字符串和集合类型"></a>字符串和集合类型</h3><h4 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h4><p>可以通过 <code>for-in</code>循环来遍历字符串中的每一个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for character in &quot;Hello, world!&quot;.characters &#123;</div><div class="line">	print(character)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h4><p>Swift提供<code>Arrays</code>、<code>Sets</code>和<code>Dictionaries</code>三种基本类型来存储集合数据。数组(Arrays)是有序数据的集合，集合(Sets)是无序无重复数据的集合，字典(Dictionaries)是无序的键值对的集合。</p>
<p>数组使用有序列表存储同一类型的多个值，相同的值可以出现在同一数组的不同位置。数组的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var intArr = [Int]()</div><div class="line">// 第二种创建方式, 带默认值</div><div class="line">var intArr = [Int](count: 4, repeatedValue: 0)</div><div class="line">// 第三种创建方式</div><div class="line">var intArr: [Int] = [1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h4 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h4><p>集合(Sets)用来存储相同数据类型并且没有顺序的值，集合保证了在集合中每个元素只出现一次。集合的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var intSets = Set&lt;Int&gt;()</div><div class="line">// 第二种创建方式</div><div class="line">var intSets: Set&lt;Int&gt; = [1, 2, 3, 4]</div></pre></td></tr></table></figure>
<h4 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典(Dictionaries)"></a>字典(Dictionaries)</h4><p>字典是存储多个相同类型值的容器。每个值都关联着一个唯一的key，key作为字典中元素的识别符。字典中的元素是没有顺序的。字典的创建方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 第一种创建方式</div><div class="line">var dic = [Int: String]()</div><div class="line">// 第二种创建方式</div><div class="line">var dic: [Int: String] = [1:&quot;name&quot;, 2:&quot;age&quot;, 3:&quot;address&quot;]</div></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>在Swift中，函数的定义十分灵活，也比较好理解。下面是个简单的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String) -&gt; String &#123;</div><div class="line">	let greeting = &quot;Hello, &quot; + personName + &quot;!&quot;</div><div class="line">	return greeting</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello(&quot;Jack&quot;))</div></pre></td></tr></table></figure>
<h4 id="无参函数"><a href="#无参函数" class="headerlink" title="无参函数"></a>无参函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func sayHello() -&gt; String &#123;</div><div class="line">	return &quot;Hello, world&quot;</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello())</div></pre></td></tr></table></figure>
<h4 id="多参数函数"><a href="#多参数函数" class="headerlink" title="多参数函数"></a>多参数函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String, alreadyGreeted: Bool) -&gt; String &#123;</div><div class="line">	if alreadyGreeted &#123;</div><div class="line">		return &quot;Already greeted!&quot;</div><div class="line">	&#125;else &#123;</div><div class="line">		return &quot;Hello, &quot; + personName + &quot;!&quot;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">print(sayHello(&quot;Jack&quot;, alreadyGreeted: true))</div></pre></td></tr></table></figure>
<h4 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">func sayHello(personName: String) &#123;</div><div class="line">	print(&quot;Hello, \(personName)!&quot;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayHello(&quot;Jack&quot;)</div></pre></td></tr></table></figure>
<h4 id="多重返回值函数"><a href="#多重返回值函数" class="headerlink" title="多重返回值函数"></a>多重返回值函数</h4><p>这个很实用，可以用元组来实现将多个值作为一个复合值返回。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">func findMinAndMaxFromArray(array: [Int]) -&gt; (min: Int, max: Int)? &#123;</div><div class="line">	var currentMin = array[0]</div><div class="line">	var currentMax = array[0]</div><div class="line">	for value in array[1..&lt;array.count] &#123;</div><div class="line">		if value &lt; currentMin &#123;</div><div class="line">			currentMin = value</div><div class="line">		&#125;else if value &gt; currentMax &#123;</div><div class="line">			currentMax = value</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	return (currentMin, currentMax)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是简单的一个求最大值和最小值的函数，返回为一个元组。</p>
<h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数的意思是可以接受零个或者多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">func arithmeticMean(numbers: Double...) -&gt; Double &#123;</div><div class="line">	var total: Double = 0</div><div class="line">	for number in numbers &#123;</div><div class="line">		total += number</div><div class="line">	&#125;</div><div class="line">	return total / Double(numbers.count)</div><div class="line">&#125;</div><div class="line"></div><div class="line">arithmeticMean(1, 2, 3, 4, 5)</div><div class="line">arithmeticMean(3, 2.3, 12.3)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这是一个充满着变化的世界，所做的每一件事，明天都可能会成为没有价值的历史。学习亦是如此，人生的选择不多。  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;满足当下，并不是一个年轻人该有的心态。拥抱Swift这个想法，其实很早就有了，只是每次都缺乏足够的耐心，最终结果未知。这次，就从一个Hello world开始，坚持下去！&lt;/p&gt;
&lt;h4 id=&quot;打印Hello-world&quot;&gt;&lt;a href=&quot;#打印Hello-world&quot; class=&quot;headerlink&quot; title=&quot;打印Hello world&quot;&gt;&lt;/a&gt;打印Hello world&lt;/h4&gt;&lt;p&gt;其实和C语言差不多，如下:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;print(&amp;quot;Hello world&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不同的是，作为一门现代编程语言，你不需要书写main方法，因为全局作用域的代码会自动当作程序的入口。还有，你再也不用写那个分号了:)&lt;/p&gt;
&lt;h4 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; title=&quot;常量和变量&quot;&gt;&lt;/a&gt;常量和变量&lt;/h4&gt;&lt;p&gt;在Swift中，用&lt;code&gt;let&lt;/code&gt;来声明常量，用&lt;code&gt;var&lt;/code&gt;来声明变量。怎么样，很简单吧，但是有时候我们需要知道常量或者变量是什么类型的，这时就需要类型标注(type annotation)，比如我们想要定义一个名为name的字符型变量：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name: String&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;冒号的意思是“是…类型”，上面这句话可以理解为“声明一个类型为String，名叫name的变量”。当然，你也可以一行定义多个：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var name, address: String&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注意：变量和常量的命名不能包含数学符号，箭头，非法的Unicode码，连线与制表符，也不能以数字开头。   &lt;/p&gt;
&lt;p&gt;如果要打印常量或者变量，很简单(Hello world已经给出)，如果想当作占位符的方式打印，使用&lt;code&gt;\()&lt;/code&gt;来完成。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;print(&amp;quot;Your name is \(name)&amp;quot;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面会打印出name的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>WebViewJavascriptBridge使用教程</title>
    <link href="http://yoursite.com/2015/10/23/WebViewJavascriptBridge%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2015/10/23/WebViewJavascriptBridge使用教程/</id>
    <published>2015-10-23T15:28:11.000Z</published>
    <updated>2017-07-29T00:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用前提"><a href="#使用前提" class="headerlink" title="使用前提"></a>使用前提</h3><h4 id="JS方面"><a href="#JS方面" class="headerlink" title="JS方面"></a>JS方面</h4><p>需要把下面这块代码添加到JS中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//这是必须要写的，用来初始化一些设置</div><div class="line">function setupWebViewJavascriptBridge(callback) &#123;</div><div class="line">  if (window.WebViewJavascriptBridge) &#123;</div><div class="line">    return callback(WebViewJavascriptBridge);</div><div class="line">  &#125;</div><div class="line">  if (window.WVJBCallbacks) &#123;</div><div class="line">    return window.WVJBCallbacks.push(callback);</div><div class="line">  &#125;</div><div class="line">  window.WVJBCallbacks = [callback];</div><div class="line">  var WVJBIframe = document.createElement(&apos;iframe&apos;);</div><div class="line">  WVJBIframe.style.display = &apos;none&apos;;</div><div class="line">  WVJBIframe.src = &apos;wvjbscheme://__BRIDGE_LOADED__&apos;;</div><div class="line">  document.documentElement.appendChild(WVJBIframe);</div><div class="line">  setTimeout(function() &#123;</div><div class="line">    document.documentElement.removeChild(WVJBIframe)</div><div class="line">  &#125;, 0)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="原生方面"><a href="#原生方面" class="headerlink" title="原生方面"></a>原生方面</h4><p>导入<code>WebViewJavascriptBridge</code>库之后，创建WKWebView，需要对WebView进行注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_jsBridge = [WKWebViewJavascriptBridge bridgeForWebView:self.webView];</div></pre></td></tr></table></figure>
<p>这样就完成了交互环境搭建，十分便利。</p>
<h3 id="JS调OC"><a href="#JS调OC" class="headerlink" title="JS调OC"></a>JS调OC</h3><p>JS调OC，OC需要注册该方法给JS使用，比如JS中有个按钮点击需要获取到原生缓存的用户信息，那么在H5中，类似这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function getUserInfo() &#123;</div><div class="line">    var params = &#123;</div><div class="line">        &apos;user_type&apos;: &apos;normal&apos;,</div><div class="line">        &apos;user_id&apos;: &apos;20113&apos;</div><div class="line">    &#125;;</div><div class="line">    WebViewJavascriptBridge.callHandler(&apos;HY_GET_USER_INFO&apos;, params, function(response) &#123;</div><div class="line">        console.log(response);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在点击H5按钮的时候调用<code>getUserInfo</code>方法，传递一下获取用户信息的条件，比如用户类型和用户ID。原生这边需要注册H5的调用，如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[self.jsBridge registerHandler:@&quot;HY_GET_USER_INFO&quot; handler:^(id data, WVJBResponseCallback responseCallback) &#123;        </div><div class="line">    NSDictionary *param = (NSDictionary *)data;</div><div class="line">    NSLog(@&quot;JS传递入参: %@&quot;, param);</div><div class="line"></div><div class="line">    // 获取到参数，进行条件查询，然后返回结果</div><div class="line">    NSDictionary *result = @&#123;@&quot;user_id&quot; : @&quot;20113&quot;, @&quot;user_name&quot; : @&quot;hyyy&quot;, @&quot;user_type&quot; : @&quot;normal&quot;, @&quot;phone&quot; : @&quot;13598021232&quot;, @&quot;address&quot; : @&quot;China&quot;&#125;;</div><div class="line">    responseCallback(result);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>需要注意的是，JS和原生的handlerName需要是一致的，上面都取的是<code>HY_GET_USER_INFO</code>。我们可以使用<code>[WKWebViewJavascriptBridge enableLogging];</code>来开启交互日志，方便调试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">WVJB RCVD: &#123;</div><div class="line">  &quot;callbackId&quot; : &quot;cb_1_1498716974384&quot;,</div><div class="line">  &quot;handlerName&quot; : &quot;HY_GET_USER_INFO&quot;,</div><div class="line">  &quot;data&quot; : &#123;</div><div class="line">    &quot;user_type&quot; : &quot;normal&quot;,</div><div class="line">    &quot;user_id&quot; : &quot;20113&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">WVJB SEND: &#123;&quot;responseId&quot;:&quot;cb_1_1498716974384&quot;,&quot;responseData&quot;:&#123;&quot;user_type&quot;:&quot;normal&quot;,&quot;phone&quot;:&quot;13598021232&quot;,&quot;address&quot;:&quot;China&quot;,&quot;user_id&quot;:&quot;20113&quot;,&quot;user_name&quot;:&quot;hyyy&quot;&#125;&#125;</div></pre></td></tr></table></figure>
<h4 id="OC调JS"><a href="#OC调JS" class="headerlink" title="OC调JS"></a>OC调JS</h4><p>OC调用JS时，JS需要先注册该方法，然后双方约定一个handleName来实现，我们以OC获取当前JS环境的user_agent为例。</p>
<p>首先我们在JS中注册方法提供给原生调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">setupWebViewJavascriptBridge(function(bridge) &#123;</div><div class="line">    bridge.registerHandler(&apos;HY_GET_USER_AGENT&apos;, function(data, responseCallback) &#123;</div><div class="line">        var userAgent = navigator.userAgent;</div><div class="line">        responseCallback(userAgent);</div><div class="line">    &#125;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>然后在原生中进行调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 原生调用JS</div><div class="line">[self.jsBridge callHandler:@&quot;HY_GET_USER_AGENT&quot; data:nil responseCallback:^(id responseData) &#123;</div><div class="line">    NSDictionary *result = (NSDictionary *)responseData;</div><div class="line">    NSLog(@&quot;返回userAgent信息：%@&quot;, result);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>这样就可以了，可以看下返回日志。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">WVJB SEND: &#123;&quot;callbackId&quot;:&quot;objc_cb_1&quot;,&quot;handlerName&quot;:&quot;HY_GET_USER_AGENT&quot;&#125;</div><div class="line"></div><div class="line">WVJB RCVD: &#123;</div><div class="line">  &quot;responseId&quot; : &quot;objc_cb_1&quot;,</div><div class="line">  &quot;handlerName&quot; : &quot;HY_GET_USER_AGENT&quot;,</div><div class="line">  &quot;responseData&quot; : &quot;Mozilla\/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit\/603.1.30 (KHTML, like Gecko) Mobile\/14E269&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;使用前提&quot;&gt;&lt;a href=&quot;#使用前提&quot; class=&quot;headerlink&quot; title=&quot;使用前提&quot;&gt;&lt;/a&gt;使用前提&lt;/h3&gt;&lt;h4 id=&quot;JS方面&quot;&gt;&lt;a href=&quot;#JS方面&quot; class=&quot;headerlink&quot; title=&quot;JS方面&quot;&gt;&lt;/a
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Xcode调试技巧</title>
    <link href="http://yoursite.com/2015/08/21/Xcode%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2015/08/21/Xcode调试技巧/</id>
    <published>2015-08-21T11:30:48.000Z</published>
    <updated>2017-07-29T00:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>俗话说，工欲善其事，必先利其器。在iOS开发中，良好的调试技巧是十分关键的。</p>
</blockquote>
<h3 id="LLDB"><a href="#LLDB" class="headerlink" title="LLDB"></a>LLDB</h3><h4 id="po"><a href="#po" class="headerlink" title="po"></a>po</h4><p><code>po</code>是<code>print object</code>的缩写，一般用的最多了。表示显示对象的描述。如果不存在，则为nil。在开发场景中，我们可以重写debugDescription方法，可以自定义打印log信息。</p>
<p>另外，有一个<code>po</code>操作十分方便，如果需要查看视图层级关系，可以下面这个命令，十分方便：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">po [[self view] recursiveDescription]</div></pre></td></tr></table></figure>
<h4 id="p"><a href="#p" class="headerlink" title="p"></a>p</h4><p><code>p</code>命令一般用于打印基本数据类型，很简单，就不多说了。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p><code>call</code>命令可以执行一段代码，比如我们打印123，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call NSLog(@&quot;%@&quot;, @&quot;123&quot;);</div></pre></td></tr></table></figure>
<p>一般我们需要在随时修改某个view的背景颜色，方便调试，我们可以这么干：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">call [self.view setBackgroundColor:[UIColor redColor]]</div></pre></td></tr></table></figure>
<p>self.view 的背景颜色就发生了变化，神不神奇！</p>
<h4 id="bt"><a href="#bt" class="headerlink" title="bt"></a>bt</h4><p><code>bt</code>命令可以打印当前堆栈相关信息，如果要打印所有线程堆栈信息，直接<code>bt all</code>即可。学习Runloop会用到这个。</p>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p><code>image</code>一般用于寻址，通过栈地址来寻找对应的代码位置，不过一般不经常使用，直接添加一个全局断点可以解决绝大多数问题。</p>
<h4 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h4><p>常用的就是全局断点了，再也不用担心跑下代码直接到main文件里去了，全局断点还是非常实用的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;俗话说，工欲善其事，必先利其器。在iOS开发中，良好的调试技巧是十分关键的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;LLDB&quot;&gt;&lt;a href=&quot;#LLDB&quot; class=&quot;headerlink&quot; title=&quot;LLDB&quot;&gt;&lt;/a&gt;L
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>检测一串数字中是否有重复数字和递增递减组合</title>
    <link href="http://yoursite.com/2015/07/03/%E6%A3%80%E6%B5%8B%E4%B8%80%E4%B8%B2%E6%95%B0%E5%AD%97%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E9%87%8D%E5%A4%8D%E6%95%B0%E5%AD%97%E5%92%8C%E9%80%92%E5%A2%9E%E9%80%92%E5%87%8F%E7%BB%84%E5%90%88/"/>
    <id>http://yoursite.com/2015/07/03/检测一串数字中是否有重复数字和递增递减组合/</id>
    <published>2015-07-03T04:32:19.000Z</published>
    <updated>2017-07-29T00:33:06.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)validateNewPasswordRepeatCount:(NSString *)newPasswordStr &#123;</div><div class="line"></div><div class="line">    // 字符串转数组</div><div class="line">    NSMutableArray *newPasswordArr = [NSMutableArray array];</div><div class="line">    [newPasswordStr enumerateSubstringsInRange:NSMakeRange(0, [newPasswordStr length])</div><div class="line">                                       options:(NSStringEnumerationByComposedCharacterSequences)</div><div class="line">                                    usingBlock:^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop) &#123;</div><div class="line">                                        [newPasswordArr addObject:substring];</div><div class="line">                                    &#125;];</div><div class="line">    </div><div class="line">    // 统计重复数</div><div class="line">    NSCountedSet *countSet = [[NSCountedSet alloc] initWithArray:newPasswordArr];</div><div class="line">    for (id item in countSet) &#123;</div><div class="line">        NSUInteger count = [countSet countForObject:item];</div><div class="line">        if (count &gt;= 3) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (BOOL)validateNewPasswordContainIncreaseAndDecrease:(NSString *)newPasswordStr &#123;</div><div class="line"></div><div class="line">    for (int i=2; i&lt;newPasswordStr.length; i++) &#123;</div><div class="line">        NSInteger num = [[newPasswordStr substringWithRange:NSMakeRange(i, 1)] integerValue];</div><div class="line">        NSInteger num_1 = [[newPasswordStr substringWithRange:NSMakeRange(i-1, 1)] integerValue];</div><div class="line">        NSInteger num_2 = [[newPasswordStr substringWithRange:NSMakeRange(i-2, 1)] integerValue];</div><div class="line"></div><div class="line">        // 判断递增</div><div class="line">        if ((num == (num_1 + 1)) &amp;&amp; (num == num_2 + 2)) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">        // 判断递减</div><div class="line">        if ((num == (num_1 - 1)) &amp;&amp; (num == num_2 - 2)) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>数组排序、分组和去重</title>
    <link href="http://yoursite.com/2015/05/29/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%8F%8A%E5%88%86%E7%BB%84/"/>
    <id>http://yoursite.com/2015/05/29/数组排序及分组/</id>
    <published>2015-05-29T13:26:48.000Z</published>
    <updated>2017-07-29T00:37:12.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// 根据v_id前缀进行分组</div><div class="line">- (NSArray *)groupDataArrByVId:(NSArray *)dataArr &#123;</div><div class="line"></div><div class="line">    NSMutableArray *groupArr = [NSMutableArray new];</div><div class="line"></div><div class="line">    NSMutableSet *set = [NSMutableSet set];</div><div class="line">    [dataArr enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">        NSDictionary *dic = (NSDictionary *)obj;</div><div class="line">        NSString *vid = [dic objectForKey:@&quot;v_id&quot;];</div><div class="line">        NSString *preStr = [vid substringToIndex:1];</div><div class="line">        [set addObject:preStr];</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [set enumerateObjectsUsingBlock:^(id  _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, obj);</div><div class="line"></div><div class="line">        NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;v_id BEGINSWITH %@&quot;, obj];</div><div class="line">        NSArray *filterArr = [dataArr filteredArrayUsingPredicate:predicate];</div><div class="line">        [groupArr addObject:filterArr];</div><div class="line">    &#125;];</div><div class="line">    return groupArr;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 根据v_id进行排序</div><div class="line">- (NSArray *)sortDataArrayByVId:(NSArray *)dataArr &#123;</div><div class="line"></div><div class="line"></div><div class="line">    NSArray *sortArr = [dataArr sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</div><div class="line">        NSDictionary *dic1 = (NSDictionary *)obj1;</div><div class="line">        NSDictionary *dic2 = (NSDictionary *)obj2;</div><div class="line"></div><div class="line">        NSString *vid_1 = [dic1 objectForKey:@&quot;v_id&quot;];</div><div class="line">        NSString *vid_2 = [dic2 objectForKey:@&quot;v_id&quot;];</div><div class="line"></div><div class="line">        NSComparisonResult result = [vid_1 compare: vid_2];</div><div class="line">        return result;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    return sortArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是去重测试代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 数组查找重复数</div><div class="line">NSArray *stringAry = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;a&quot;];</div><div class="line">NSMutableDictionary *metadic = [NSMutableDictionary dictionary];</div><div class="line">NSMutableDictionary *dic = [NSMutableDictionary dictionary];</div><div class="line">for (NSString *sting in stringAry) &#123;</div><div class="line">    if (![metadic valueForKey:sting]) &#123;</div><div class="line">        [metadic setValue:@&quot;1&quot; forKey:sting];</div><div class="line">    &#125;else&#123;</div><div class="line">        [dic setValue:@&quot;1&quot; forKey:sting];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;%@&quot;, [dic.allKeys copy]);</div><div class="line"></div><div class="line">// 数组去重</div><div class="line">NSArray *stringAry = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;a&quot;];</div><div class="line">NSSet *set = [NSSet setWithArray:stringAry];</div><div class="line">NSLog(@&quot;%@&quot;, set.allObjects);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="http://yoursite.com/2015/03/15/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2015/03/15/二维数组中的查找/</id>
    <published>2015-03-15T13:36:58.000Z</published>
    <updated>2017-07-29T00:38:46.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><blockquote>
<p>在一个二维数组中，每一行和每一列从左到右、从上到下都按递增顺序排序，请完成一个函数，输入这样一个二维数组和一个整数，来判断数组中是否含有该整数。比如按照下面的二维数组，我们查找7，则返回true；如果查找5，返回false。</p>
</blockquote>
<table>
<thead>
<tr>
<th>- -</th>
<th>–</th>
<th>–</th>
<th>–</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>9</td>
<td>12</td>
</tr>
<tr>
<td>4</td>
<td>7</td>
<td>10</td>
<td>13</td>
</tr>
<tr>
<td>6</td>
<td>8</td>
<td>11</td>
<td>15</td>
</tr>
</tbody>
</table>
<h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4><p>用两个for循环去做，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)hy_findKeyword1:(NSArray&lt;NSArray&lt;NSNumber *&gt; *&gt; *)array keywords:(NSNumber *)keywrods &#123;</div><div class="line">    for (int i=0; i&lt;array.count; i++) &#123;</div><div class="line">        NSArray *tempArr = array[i];</div><div class="line">        for (int j=0; j &lt; tempArr.count; j++) &#123;</div><div class="line">            NSNumber *number = tempArr[j];</div><div class="line">            if ([number integerValue] == [keywrods integerValue]) &#123;</div><div class="line">                return YES;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h4><p>从右上角的元素开始判断，如果关键元素大于最右上角的元素，那么右上角的那一行可以忽略掉；如果小于，那么右上角那一列可以忽略掉，等于则直接返回。以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)hy_findKeyword2:(NSArray&lt;NSArray&lt;NSNumber *&gt; *&gt; *)array keywords:(NSNumber *)keywrods &#123;</div><div class="line">    NSInteger col = array[0].count;</div><div class="line"></div><div class="line">    NSInteger i = 0;</div><div class="line">    NSInteger j = col - 1;</div><div class="line"></div><div class="line">    while (i&lt;col-1 &amp;&amp; j&gt;=0) &#123;</div><div class="line">        NSNumber *tempValue = array[i][j];</div><div class="line">        if ([tempValue integerValue] &gt; [keywrods integerValue]) &#123;</div><div class="line">            // 如果该值大于关键值</div><div class="line">            j--;</div><div class="line">        &#125;else if ([tempValue integerValue] &lt; [keywrods integerValue]) &#123;</div><div class="line">            // 如果该值小于关键值</div><div class="line">            i++;</div><div class="line">        &#125;else &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h4><p>从左下角的元素开始判断，如果关键元素大于左下角的元素，那么左下角相关的那一列可以忽略掉；如果小于，那么左下角相关的那一行可以忽略掉，等于则直接返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)hy_findKeyword3:(NSArray&lt;NSArray&lt;NSNumber *&gt; *&gt; *)array keywords:(NSNumber *)keywrods &#123;</div><div class="line">    NSInteger row = array[0].count;</div><div class="line"></div><div class="line">    NSInteger i = row - 1;</div><div class="line">    NSInteger j = 0;</div><div class="line"></div><div class="line">    while (i&gt;=0 &amp;&amp; j&lt;row-1) &#123;</div><div class="line">        NSNumber *tempValue = array[i][j];</div><div class="line">        if ([tempValue integerValue] &gt; [keywrods integerValue]) &#123;</div><div class="line">            // 如果该值大于关键值</div><div class="line">            i--;</div><div class="line">        &#125;else if ([tempValue integerValue] &lt; [keywrods integerValue]) &#123;</div><div class="line">            // 如果该值小于关键值</div><div class="line">            j++;</div><div class="line">        &#125;else &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;在一个二维数组中，每一行和每一列从左到右、从上到下都按递增顺序排序
    
    </summary>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
