<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyyy的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-18T07:52:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hyyy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS小结之多线程</title>
    <link href="http://yoursite.com/2017/06/18/iOS%E5%B0%8F%E7%BB%93%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/06/18/iOS小结之多线程/</id>
    <published>2017-06-18T07:49:32.000Z</published>
    <updated>2017-06-18T07:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第三篇，来总结总结iOS中多线程操作。</p>
</blockquote>
<h3 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h3><p>对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。</p>
<p>谈细节之前里，我们得说下有关多线程的几个概念。</p>
<h4 id="串行和并发"><a href="#串行和并发" class="headerlink" title="串行和并发"></a>串行和并发</h4><p>串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。</p>
<h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><p>同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。</p>
<h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><p>临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。</p>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如<code>NSDictionary</code>就是线程安全的，可以在多线程中使用它，不会出现问题，而<code>NSMutableDictionary</code>是线程不安全的，所以使用<code>NSMutableDictionary</code>的时候应该保证每次只能有一个线程访问它。</p>
<h4 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h4><p>上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。</p>
<a id="more"></a>
<h3 id="iOS多线程方案"><a href="#iOS多线程方案" class="headerlink" title="iOS多线程方案"></a>iOS多线程方案</h3><h4 id="Pthreads"><a href="#Pthreads" class="headerlink" title="Pthreads"></a>Pthreads</h4><p><code>Pthreads</code>是基于C语言的通用多线程API，在日常开发中基本上用不到，并且目前在Swift中貌似并不能直接调用这套API。所以这种方案只提一下，不过多介绍。</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p><code>NSThread</code>是一套比较轻量级的多线程方案，可以直观地控制线程对象，一个<code>NSThread</code>代表一条线程，但是需要自己管理线程的生命周期，线程同步等问题，</p>
<p>创建thread目前所了解到的有4种方式，其中类方法两个，实例方法两个。类方法创建线程后会自动启动该线程，而实例方法只会创建线程，启动需要手动去做。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 第一种类方法</div><div class="line">[NSThread detachNewThreadSelector:@selector(threadHandler) toTarget:self withObject:nil];</div><div class="line"></div><div class="line">- (void)threadHandler &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 第二个类方法</div><div class="line">[NSThread detachNewThreadWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;block current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>下面是两种实例方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 第一个实例方法</div><div class="line">NSThread *thread1 = [[NSThread alloc] initWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[thread1 start];</div><div class="line"></div><div class="line">// 第二个实例方法</div><div class="line">NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(threadHandler:) object:@&#123;@&quot;title&quot; : @&quot;2123&quot;&#125;];</div><div class="line">[thread2 start];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了上面的之外，<code>NSThread</code>还提供了一个<code>NSObject+NSThreadPerformAdditions</code>，用于在NSObject中执行线程调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在主线程执行一个任务，后者区别在于可以指定在哪种Runloop模式下运行，有关Runloop可以参考上篇文章。</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelectorOnMainThread:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在指定的线程中执行一个任务。</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES];</div><div class="line">[self performSelector:@selector(threadHandler:) onThread:[NSThread currentThread] withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125; waitUntilDone:YES modes:@[NSDefaultRunLoopMode]];</div><div class="line"></div><div class="line">// 在后台隐形创建线程，执行一个任务</div><div class="line">[self performSelectorInBackground:@selector(threadHandler:) withObject:@&#123;@&quot;title&quot; : @&quot;123&quot;&#125;];</div><div class="line"></div><div class="line">- (void)threadHandler:(NSDictionary *)dic &#123;</div><div class="line">    NSThread *currentThread = [NSThread currentThread];</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, currentThread);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，NSThread还提供了设置线程优先级功能，叫做NSQualityOfService，一共分为一下几种：</p>
<ul>
<li>NSQualityOfServiceUserInteractive。用于用户交互，最高优先级</li>
<li>NSQualityOfServiceUserInitiated。用于执行需要立即返回的的任务，次高优先级</li>
<li>NSQualityOfServiceDefault。线程默认优先级</li>
<li>NSQualityOfServiceUtility。用于执行普通任务，普通优先级</li>
<li>NSQualityOfServiceBackground。最低优先级，用于执行不重要的任务</li>
</ul>
<p>还有其他一些线程操作，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 线程休眠，休眠线程会阻塞当前线程</div><div class="line">[NSThread sleepForTimeInterval:5.0];</div><div class="line">[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:5.0]];</div><div class="line"></div><div class="line">// 线程取消，调用此方法并不会马上停止线程运行，只仅仅是线程状态记录</div><div class="line">[thread cancel];</div><div class="line"></div><div class="line">// 线程停止，执行此方法会立即终止主线程外其他所有线程，所以调用请慎用。</div><div class="line">[NSThread exit];</div><div class="line"></div><div class="line">// 获取当前线程</div><div class="line">[NSThread currentThread];</div><div class="line"></div><div class="line">// 获取主线程</div><div class="line">[NSThread mainThread];</div><div class="line"></div><div class="line">// 停止当前线程的Runloop</div><div class="line">CFRunLoopStop(CFRunLoopGetCurrent());</div></pre></td></tr></table></figure>
<p>如果有多个线程共享一块资源，对资源进行操作时候，还涉及到线程同步问题，一段时间只允许一条线程来操作资源，不然会引起冲突，iOS实现线程加锁有NSLock和@synchronized两种方式。其用法也比较简单，在这里就不过多介绍。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD全称是Grand Central Dispatch，是为了给iOS和mac的多核硬件上执行支持，其实现方式是一套底层C API。通过GCD，开发者不用和线程打交道，只需要使用一个Block就可以实现多线程操作。GCD提供的API简单易懂，提供了一个易于使用的并发模型，对于开发者来说，并不需要关心多线程的并发问题，GCD底层自动处理这些逻辑。</p>
<p>出了这些之外，GCD其实还可以根据当前的系统负载来增减线程数量，我们都知道线程的创建切换都是需要代价的，是有消耗的，所以使用GCD还可以增加效率，提供更高的性能。</p>
<p>GCD操作是需要通过队列来操作的，有三种队列可以使用。</p>
<ul>
<li>串行队列(Serial)。串行队列的特点是以先进先出的顺序来执行的，队列内的东西是以顺序执行的，但是多个串行队列直接是以并发执行的。</li>
<li>并行队列(Concurrent)。并行队列和串行队列相反，可以同时执行多个任务，但是多个任务之间，仍然是以先进先出的顺序执行的，区别在于，并行队列会跟酒系统负载，尽可能多地创建线程去执行这些任务。但是哪个任务先执行完毕是不确定的。</li>
<li>主线程队列(Main dispatch queue)。实际上，主线程队列是一个和主线程相关的串行队列。这个队列中的任务每次只会有一个执行。可以保证所有的任务都会在主线程执行，所以涉及到UI操作的需要使用这个队列来完成。</li>
</ul>
<p>创建一个串行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(@&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line"></div><div class="line">// 这种也可以，NULL默认就是串行</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div></pre></td></tr></table></figure>
<p>创建一个并行队列，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;coml.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">// 也可以用下面这种</div><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div></pre></td></tr></table></figure>
<p>主线程队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<p>GCD往队列里添加任务有两种方式，一种是异步，一种是同步。</p>
<ul>
<li>异步(dispatch_async)。是一个异步添加操作，dispatch_async会立即返回；</li>
<li>同步(dispatch_sync)。是一个同步添加操作，dispatch_sync区别是会阻塞当前线程，会等待block里的任务执行完毕之后才会返回。</li>
</ul>
<p>dispatch_async添加任务，会立即返回，所以下面的打印顺序不确定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果：</div><div class="line">ThreadTest[17614:2597588] ========2</div><div class="line">ThreadTest[17614:2597588] ========1</div></pre></td></tr></table></figure>
<p>如果是dispatch_sync，由于是同步，所以打印结果是有顺序的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, NULL);</div><div class="line">dispatch_sync(queue, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">NSLog(@&quot;========2&quot;);</div><div class="line"></div><div class="line">// 执行结果</div><div class="line">ThreadTest[17599:2595130] ========1</div><div class="line">ThreadTest[17599:2595130] ========2</div></pre></td></tr></table></figure>
<p>但是dispatch_sync尽量少用，使用不当会造成死锁。比如下面的代码就会造成死锁：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_sync(dispatch_get_main_queue(), ^(void)&#123;</div><div class="line">    NSLog(@&quot;这里死锁了&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的是，死锁并不是这里使用了主线程造成的，不用主线程，照样可以造成死锁。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.hyyy.thread&quot;, DISPATCH_QUEUE_SERIAL);</div><div class="line">NSLog(@&quot;========1&quot;);</div><div class="line">dispatch_async(serialQueue, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_sync(serialQueue, ^&#123;</div><div class="line">        NSLog(@&quot;========3&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种也会发生死锁，所以不要听信什么主线程的问题，不是主线程照样可以发生死锁。死锁真的发生的原因是dispatch_sync添加进的queue队列是当前queue队列。在主线程死锁的那段代码中，我们调用的dispatch_sync是添加在主线程queue中，使主线程堵塞，而我们的Block又需要主线程queue来执行，所以相互等待，造成死锁了。</p>
<p>但是为什么添加队列换成并行队列就不会有问题呢？还是上面的概念，对于并行队列中任务的执行，其执行开始和结束并不取决于上一个任务的结束时间，只仅仅取决于任务的耗时。即便任务是以同步的方式添加进去，但是在并行队列中也会在另外一个线程去跑这个任务。</p>
<p>这里还需要提一个题外话，在并发队列里的Block何时执行，开发者是不用知道的，完全取决于GCD，但是我们也是有方法可以让其按照顺序执行。</p>
<p>GCD的使用场景有很多，我们一个一个举例来说明。</p>
<p><strong>后台下载显示图片</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    NSURL * url = [NSURL URLWithString:@&quot;http://www.yourimage.com&quot;];</div><div class="line">    NSError * error;</div><div class="line">    NSString * data = [NSString stringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:&amp;error];</div><div class="line">    if (data != nil) &#123;</div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">            self.imageView.image = [UIImage imageWithData:data];</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        NSLog(@&quot;error when download:%@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这是一个经典的使用场景，有时候我们需要后台处理一个任务，然后在主线程进行UI渲染，可以这么干。</p>
<p><strong>单例模式</strong></p>
<p>单例模式是设计模式中最简单的一种了，它的目的是创建的类对象在系统中是唯一的，一个类只有一个实例，节约系统资源。一般我们创建一个单例会这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//Singleton.h</div><div class="line">@interface Singleton : NSObject</div><div class="line">+ (Singleton *)sharedInstance;</div><div class="line">@end</div><div class="line"></div><div class="line">//Singleton.m</div><div class="line">@implementation Singleton</div><div class="line">static Singleton * sharedSingleton = nil;</div><div class="line">+ (Singleton *) sharedInstance &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        sharedSingleton = [[Singleton alloc] init];</div><div class="line">    &#125;);</div><div class="line">    return sharedSingleton;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这里我们用到了dispatch_once_t，对于给定的token来说，Block里的代码必定会执行，并且会仅执行一次。最重要的一点是，这里的操作是线程安全的，十分高效。但是需要注意的是token这个东西是应该声明称static或者global，这样来保证每次传进去的token是相同的。</p>
<p><strong>dispatch_after延后执行</strong></p>
<p>dispatch_after可以做到使一块代码延时执行，但是需要注意的是，这里的延时是有歧义的，dispatch_after做到的仅是延时把这一项任务提交到队列中去，至于什么时候执行，是和GCD内部处理逻辑有关的。</p>
<p>比如我想0.5秒之后发送一条通知，可以这么干。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:HY_AFTER_NOTIFICATION object:nil];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>dispatch_apply快速迭代</strong></p>
<p>dispatch_apply和遍历的效果差不多，其作用是把指定次数的block添加到queue中，好处是dispatch_apply可以不用管理线程方面的问题，GCD会自动处理并发现象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSArray *array = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    NSString *str = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %@&quot;, str);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><strong>Dispatch_groups</strong></p>
<p>Dispatch_groups作用是用来监视多个并行任务的执行，来进行线程同步的。在多个任务执行完毕后，想要执行结束处理，就可以使用Dispatch_groups来完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue2, ^&#123;</div><div class="line">    NSLog(@&quot;========3&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">========3</div><div class="line">========1</div><div class="line">========2</div><div class="line">========end</div></pre></td></tr></table></figure>
<p>可以看到，上面三个任务执行完毕之后，才会走最后一个block回调，我们可以利用这种模式做很多事。但是千万不要像下面这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_queue_t queue2 = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========1&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue1, ^&#123;</div><div class="line">    dispatch_async(queue2, ^&#123;</div><div class="line">        NSLog(@&quot;========2&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这么写会有问题，dispatch_group_async里执行的是异步任务，而dispatch_group_notify并不会等待异步任务完成，如果真的这么做，那就需要dispatch_group_enter和dispatch_group_leave来进行约束，也是我用的比较多的一种。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========1&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_enter(group);</div><div class="line">dispatch_async(queue, ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========2&quot;);</div><div class="line">    dispatch_group_leave(group);</div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    sleep(3);</div><div class="line">    NSLog(@&quot;========end&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>需要注意的事，dispatch_group_enter和dispatch_group_leave总是对应出现的，类似于引用计数原理，有加有减。</p>
<p><strong>dispatch_barrier并发问题</strong></p>
<p>在并行队列里，有时候我们需要每次只单独执行一个任务，也就是当有个任务执行的时候，不允许其他任务执行，类似于多线程读写问题，这时候Dispatch Barrier就发挥了作用。</p>
<p>Dispatch Barrier可以保证提交的block是指定队列里某个时段唯一执行的一个，下面用一个示例来演示一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t dataQueue = dispatch_queue_create(&quot;com.hyyy.gcd&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:2.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">//等待前面的都完成，在执行barrier后面的</div><div class="line">dispatch_barrier_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;写数据&quot;);</div><div class="line">    [NSThread sleepForTimeInterval:1];</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    [NSThread sleepForTimeInterval:1.f];</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_async(dataQueue, ^&#123;</div><div class="line">    NSLog(@&quot;读数据&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在进行写数据的时候，因为使用了Dispatch Barrier，不会发生读数据的操作，所以保证了每次写入数据只会有一个任务在执行。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>相比于GCD，NSOperation显得并没有那么流行，但是称得上是先进的面向对象的多线程解决办法。同样，对于开发者来讲，我们根本不用考虑线程的生命周期、同步，加锁等晦涩问题。</p>
<p>使用NSOperation有三种方式，NSInvocationOperation、NSBlockOperation和自定义子类继承NSOperation。</p>
<p><strong>NSInvocationOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x60000007a840&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>NSInvocationOperation默认情况下，并不会新开一个线程去跑，而是在当前线程去执行任务，可以将NSInvocationOperation放到NSOperationQueue中，即可实现异步操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(operationHandler) object:nil];</div><div class="line"></div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">- (void)operationHandler &#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000077140&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x60800006e440&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p><strong>NSBlockOperation</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000753c0&gt;&#123;number = 1, name = main&#125;</div></pre></td></tr></table></figure>
<p>和NSInvocationOperation一样，默认NSBlockOperation只会在当前线程上执行。如果需要新开线程操作，可以添加到NSOperationQueue中即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">    NSLog(@&quot;main thread: %@&quot;, [NSThread mainThread]);</div><div class="line">&#125;];</div><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">[queue addOperation:operation];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x60800007d7c0&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">main thread: &lt;NSThread: 0x6000000767c0&gt;&#123;number = 1, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>另外，可以使用addExecutionBlock添加额外的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x6000000771c0&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000264280&gt;&#123;number = 5, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000260980&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000002640c0&gt;&#123;number = 3, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>可以看到，使用addExecutionBlock会在新线程中去执行。但是并不是每次都会创建，我们可以试下多创建几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation addExecutionBlock:^&#123;</div><div class="line">    NSLog(@&quot;current thread: %@&quot;, [NSThread currentThread]);</div><div class="line">&#125;];</div><div class="line">[operation start];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000071bc0&gt;&#123;number = 4, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x600000065600&gt;&#123;number = 1, name = main&#125;</div><div class="line">current thread: &lt;NSThread: 0x608000072040&gt;&#123;number = 3, name = (null)&#125;</div><div class="line">current thread: &lt;NSThread: 0x6000000706c0&gt;&#123;number = 5, name = (null)&#125;</div></pre></td></tr></table></figure>
<p>所以，如果NSBlockOperation封装的操作数大于1的时候,才会执行异步操作.不然也是在当前线程下执行的。</p>
<p>另外，NSOperation可以取消的，这个算是一大特色了，也是NSOperation的使用场景之一了。NSOperation有三种状态，isReady -&gt; isExecuting -&gt; isFinish， 如果在Ready的状态中对NSOperation进行取消，NSOperation会进入Finish状态。但是Operation已经开始执行了，就会一直运行到结束，或者由我们进行取消。也就是说Operation已经在executing状态，我们调用cancle方法系统不会中止线程的，这需要我们在任务过程中检测取消事件，并中止线程的执行，还要注意一点我们要释放内存或资源。</p>
<p>需要注意的是，调用cancel并不会退出线程，需要自行终止线程的运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (![operation isCancelled]) &#123;</div><div class="line">    [operation cancel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有，NSOpertion可以设置优先级，从而改变其执行顺序，我们举个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1后执行&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2先执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 addDependency:operation2];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2先执行</div><div class="line">operation1后执行</div></pre></td></tr></table></figure>
<p>但是不能互相添加依赖，不然就死锁了，两个永远都不会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[operation1 addDependency:operation2];</div><div class="line">[operation2 addDependency:operation1];</div></pre></td></tr></table></figure>
<p>有些时候，我们需要监听到任务完成后的回调事件，NSOperation也提供了这个方法，叫CompletionBlock。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</div><div class="line">NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation1 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation1执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行&quot;);</div><div class="line">&#125;];</div><div class="line">[operation2 setCompletionBlock:^&#123;</div><div class="line">    NSLog(@&quot;operation2执行完毕&quot;);</div><div class="line">&#125;];</div><div class="line">[queue addOperation:operation1];</div><div class="line">[queue addOperation:operation2];</div><div class="line"></div><div class="line">// 运行结果</div><div class="line">operation2执行</div><div class="line">operation1执行</div><div class="line">operation2执行完毕</div><div class="line">operation1执行完毕</div></pre></td></tr></table></figure>
<p>还有自定义NSOperation，由于不是经常能用到，所以就不多做介绍了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS多线程就总结到这里了，不过一般开发中用的GCD比较多，偶尔会用到NSOperation，这两个理解了就够用了，根据需求来定技术方案。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第三篇，来总结总结iOS中多线程操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;多线程概述&quot;&gt;&lt;a href=&quot;#多线程概述&quot; class=&quot;headerlink&quot; title=&quot;多线程概述&quot;&gt;&lt;/a&gt;多线程概述&lt;/h3&gt;&lt;p&gt;对于ios系统中的某个App来讲，是单进程多线程方式来工作。一般来说，使用多线程的好处是可以把程序分成相对独立的几个模块，可以有效的防止某个模块堵塞的时候导致整个程序卡死；还有就是提高运行效率，现在CPU都是多核，多个核可以同时跑，可以同时执行多条线程。&lt;/p&gt;
&lt;p&gt;谈细节之前里，我们得说下有关多线程的几个概念。&lt;/p&gt;
&lt;h4 id=&quot;串行和并发&quot;&gt;&lt;a href=&quot;#串行和并发&quot; class=&quot;headerlink&quot; title=&quot;串行和并发&quot;&gt;&lt;/a&gt;串行和并发&lt;/h4&gt;&lt;p&gt;串行的意思是在多个任务下，每次只会有一个任务被执行，并发的意思是同一时间多个任务同时发生。并发是一种现象，解决并发现象的技术，叫做并行。我们经常说的多线程编程，说的就是并行技术，可以让多个CPU同时执行，加快执行速度，提高执行效率。&lt;/p&gt;
&lt;h4 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h4&gt;&lt;p&gt;同步的意思是在多任务中，一个任务只能等待另一个任务完成之后，他才可以进行，而异步的意思是一个任务的执行，不需要等待上一个任务的执行，不会发生堵塞。&lt;/p&gt;
&lt;h4 id=&quot;临界区&quot;&gt;&lt;a href=&quot;#临界区&quot; class=&quot;headerlink&quot; title=&quot;临界区&quot;&gt;&lt;/a&gt;临界区&lt;/h4&gt;&lt;p&gt;临界区是一种资源，这块资源不能并发执行，就叫做临界区。我们一般所看到的，临界区就是一个代码块。因为临界区资源如果可以被多个线程同时进行操作，比如读写，就可能出现异常。&lt;/p&gt;
&lt;h4 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h4&gt;&lt;p&gt;死锁就是指两条线程互相都在等待对方执行完毕，才能进入下一步操作。由于两条线程都不能执行下一步，所以造成死锁，卡住不动了。&lt;/p&gt;
&lt;h4 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h4&gt;&lt;p&gt;线程安全在iOS开发中应该听到多很多次，指的是在多线程中或者并发任务中可以被安全地调用，就称为线程安全。比如&lt;code&gt;NSDictionary&lt;/code&gt;就是线程安全的，可以在多线程中使用它，不会出现问题，而&lt;code&gt;NSMutableDictionary&lt;/code&gt;是线程不安全的，所以使用&lt;code&gt;NSMutableDictionary&lt;/code&gt;的时候应该保证每次只能有一个线程访问它。&lt;/p&gt;
&lt;h4 id=&quot;上下文切换&quot;&gt;&lt;a href=&quot;#上下文切换&quot; class=&quot;headerlink&quot; title=&quot;上下文切换&quot;&gt;&lt;/a&gt;上下文切换&lt;/h4&gt;&lt;p&gt;上下文切换指的是在一条进程中切换不同线程时，线程的等待和恢复执行的过程。这一过程中会带来一些额外的开销。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之Runloop</title>
    <link href="http://yoursite.com/2017/06/11/iOS%E5%B0%8F%E7%BB%93%E4%B9%8BRunloop/"/>
    <id>http://yoursite.com/2017/06/11/iOS小结之Runloop/</id>
    <published>2017-06-11T07:34:03.000Z</published>
    <updated>2017-06-11T07:39:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>小结第二篇，来总结下Runloop的知识。</p>
</blockquote>
<h3 id="Runloop概述"><a href="#Runloop概述" class="headerlink" title="Runloop概述"></a>Runloop概述</h3><p>学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function loop() &#123;</div><div class="line">    initLoop();</div><div class="line">    do &#123;</div><div class="line">        if(message_hasTask()) &#123;</div><div class="line">            message_execute(get_current_message());</div><div class="line">        &#125;</div><div class="line">    &#125; while (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。</p>
<p>这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。</p>
<a id="more"></a>
<p>在iOS中，提供了两种有关的对象，一种是<code>NSRunLoop</code>，另外一种是<code>CFRunLoopRef</code>。<code>CFRunLoopRef</code>是基于<code>CoreFoundation</code>框架的，提供了纯C函数的API，所以这些API都是线程安全的。我们一般听到的<code>NSRunLoop</code>，是对<code>CFRunLoopRef</code>的封装，加上了面向对象的东西，所以这些API不是安全的。</p>
<p>所以，一般讲解<code>Runloop</code>的文章，其实都是在分析<code>CFRunLoopRef</code>这个东西。<code>CFRunLoopRef</code>的具体实现，苹果也将它开源了出来，可以在引用里看到其链接，这里就不再给出。</p>
<h3 id="Runloop和线程"><a href="#Runloop和线程" class="headerlink" title="Runloop和线程"></a>Runloop和线程</h3><p>上面可以看出，需要实现一个Runloop模型，是基于线程之上的。所以，Runloop和线程是息息相关的，在iOS系统中，Runloop属于线程的基础架构部分。每个线程，包括程序的主线程，都有与之的Runloop模型。</p>
<p>其实，Runloop和线程的绑定，是保存在一个全局的Dictionary中，线程和Runloop之间是一一对应的。当线程创建后，默认并不会启动Runloop，只有主动获取的时候，Runloop才会被创建，当线程结束后，对应的Runloop也会随之销毁。但是有个例外，就是主线程对应的Runloop默认是启动的。当程序启动的时候，会执行下面的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">   @autoreleasepool &#123;</div><div class="line">       return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，在<code>UIApplicationMain</code>内部帮我们开启了主线程的Runloop，相当于说，主线程的Runloop是默认启动的。这样我们才可以监听触摸事件、页面刷新等等功能。</p>
<h3 id="Runloop结构"><a href="#Runloop结构" class="headerlink" title="Runloop结构"></a>Runloop结构</h3><p>Runloop主要由5个类组成。如下所示：</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其关系如下图：</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="Runloop关系图"></p>
<p>一个Runloop包含多个Mode，每个Mode里面又包含多个Source/Timer/Observer。但是，需要注意的是，每次开启Runloop的时候，只会使用其中一个Mode，一般叫做currentMode。有时候实际场景中需要切换Mode，切换的时候，只能先退出Mode，然后再添加上新的Mode。</p>
<h4 id="Source0-和-Source1"><a href="#Source0-和-Source1" class="headerlink" title="Source0 和 Source1"></a>Source0 和 Source1</h4><p><strong>CFRunLoopSourceRef</strong>有两个版本：Source0和Source1，Source的作用是给线程发送异步事件。其中Source0是接收App内部的事件，比如用户点击滑动等事件，App自己负责处理，需要手动来唤醒Runloop，来处理这个事件；Source1是通过内核和其他线程发送消息用的，可以自动唤醒Runloop的线程。</p>
<h4 id="CFRunLoopTimerRef"><a href="#CFRunLoopTimerRef" class="headerlink" title="CFRunLoopTimerRef"></a>CFRunLoopTimerRef</h4><p>顾名思义，<strong>CFRunLoopTimerRef</strong>是基于时间来出发的，和NSTimer底层一样。当其加入到Runloop时，Runloop会注册对应的时间点，当时间点到时，Runloop会唤醒执行那个回调。常见的使用场景比如：延迟执行某个方法、CADisplayLink的使用等等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</div><div class="line"></div><div class="line">+ (CADisplayLink *)displayLinkWithTarget:(id)target selector:(SEL)sel;</div></pre></td></tr></table></figure>
<h4 id="CFRunLoopObserverRef"><a href="#CFRunLoopObserverRef" class="headerlink" title="CFRunLoopObserverRef"></a>CFRunLoopObserverRef</h4><p><strong>CFRunLoopObserverRef</strong>是基于观察者模式，和<code>CFRunLoopTimerRef</code>类似，每个Observer都会包含有一个回调，用于监听Runloop的状态变化。可以监听到的状态变化有如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面所介绍的Source、Timer和Observer都可以添加到多个Model当中，但是如果在一个Mode当中添加多个，是不会起效果的，有一种特殊情况，就是当一个Mode里什么都没有，则这个Runloop就会直接退出。</p>
<h3 id="Runloop-Mode"><a href="#Runloop-Mode" class="headerlink" title="Runloop Mode"></a>Runloop Mode</h3><p>上面已经说过，Runloop的运行是基于特定的Mode，其数据结构如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</div><div class="line">    CFMutableSetRef _sources0;    // Set</div><div class="line">    CFMutableSetRef _sources1;    // Set</div><div class="line">    CFMutableArrayRef _observers; // Array</div><div class="line">    CFMutableArrayRef _timers;    // Array</div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     // Set</div><div class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</div><div class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</div><div class="line">    CFMutableSetRef _modes;           // Set</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里需要注意一下，有一个很关键的属性叫<code>CommonModes</code>，每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>在iOS系统中包含了两个Mode，一个是<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>。这两个Mode都已经被注册成了CommonMode，一般App主线程的Runloop默认是<code>NSDefaultRunLoopMode</code>，当UIScrollView滑动的时候，Runloop就会退出，然后切换到<code>UITrackingRunLoopMode</code>。这两个是苹果公开的Mode，当然，还有一些私有Mode，就在这里不阐述了，有兴趣的读者可以Google一下。</p>
<p>出了上面这些，苹果还提供一个操作<code>CommonModes</code>的字符串，可以对所有CommonMode进行操作，叫做<code>kCFRunLoopCommonModes</code>，有些同学容易将这个东西和上面的Mode混淆，其实概念还是不一样的，<code>kCFRunLoopCommonModes</code>并不是一个新的Mode，在App主线程的Runloop中，是一个<code>CommonModes</code>组合，包含<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两种Mode。这里的话在下面NSTimer的应用场景中详细讲下。</p>
<h3 id="Runloop常见应用场景"><a href="#Runloop常见应用场景" class="headerlink" title="Runloop常见应用场景"></a>Runloop常见应用场景</h3><h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>AutoreleasePool其实和Runloop是有关系的，有一个经典的面试题是问<code>AutoreleasePool对象是什么时候释放的？</code>，什么答案都有，标准答案应该是AutoreleasePool对象应该是在当前Runloop迭代结束之后释放的。</p>
<p>当App启动之后，iOS会在主线程注册两个Observer，第一个Observer是监听即将进入Runloop的状态，监听到后，来创建AutoreleasePool对象，其优先级也是最高的，要保证创建AutoreleasePool发生在其他所有回调之前；第二个Observer是监听Runloop准备休眠状态，来释放旧的AutoreleasePool对象，并且创建新的AutoreleasePool对象以供使用，另外还需要监听即将退出Runloop的状态，优先级是最低的，以此来保证释放操作在其他所有回调之后。</p>
<p>所以，如果以后有人再问你<code>AutoreleasePool对象是什么时候释放的？</code>，一定要说这和Runloop有关系，当Runloop准备休眠的时候，会释放旧的AutoreleasePool对象，创建新的AutoreleasePool对象，当Runloop即将退出的时候，会释放掉相关所有的AutoreleasePool对象。</p>
<h4 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h4><p>NSTimer在时间点的触发，是基于Runloop运行的，使用NSTimer之前，都需要将其注册到Runloop上。其实NSTimer就是CFRunLoopTimerRef，一个NSTimer注册好之后，Runloop会自动在时间节点注册好事件。但是Runloop为了节省资源，并不会在非常准确的时间节点调用定时器。为此，NSTimer专门提供了一个tolerance属性，来设置宽容度，标记当时间节点到来之后，容许有多少误差可以触发回调。如果错过了某个时间节点，就只能等下一个时间节点的到来。</p>
<p>回到之前Mode的话题，当UISCrollView进行滚动的时候，NSTimer就无法正常工作，停止滑动又回恢复正常。这个原因是，添加到Runloop的NSTimer默认是以<code>NSDefaultRunLoopMode</code>模式在工作，当UIScrollView进行滑动的时候，Runloop会退出，然后切换到<code>UITrackingRunLoopMode</code>模式。由于NSTimer不是在这个模式下运行的，所以不会触发定时任务，无法工作。</p>
<p>要解决这个问题，我们就需要将NSTimer在<code>NSDefaultRunLoopMode</code>和<code>UITrackingRunLoopMode</code>两个模式下工作，在UIScrollView滑动的时候也可以进行触发定时任务。所以，我们需要使用到<code>kCFRunLoopCommonModes</code>来完成任务。一般使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure>
<h4 id="事件响应和手势识别"><a href="#事件响应和手势识别" class="headerlink" title="事件响应和手势识别"></a>事件响应和手势识别</h4><p>事件响应其实和Runloop也是有关系的，为此，苹果专门注册了一个Source1用来接收系统事件。当手机的硬件发生感应，比如触摸、锁屏和摇晃，苹果注册的这个Source1都会收到回调，然后会将事件进行应用内部分发。</p>
<p>然后，App内主线程的Runloop会触发Source0事件，Source0收到回调进行下一步操作。</p>
<p>不同于事件响应，对于手势识别，收到苹果Source1对应用内部分发事件后，首先先将所有的手势回调打断，将所对应的UIGestureRecognizer事件标记为待处理，然后苹果会注册一个Observer来监听Runloop即将进入休眠的状态，然后在Observer回调里执行GestureRecognizer的回调。</p>
<h4 id="UI更新"><a href="#UI更新" class="headerlink" title="UI更新"></a>UI更新</h4><p>UI更新也和Runloop有关，当在操作UI时，改变了UI的大小、层次等，这个 UIView/CALayer就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个Observer来监听Runloop即将进入休眠和即将退出的状态，然后在其Observer回调里遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>GCD底层也和Runloop有关，当调用<code>dispatch_async(dispatch_get_main_queue(), block)</code>时，libDispatch会向主线程的RunLoop发送消息，RunLoop会被唤醒，并从消息中取得这个block，并在回调里执行这个block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>PerformSelecter其实是创建了一个Timer，然后添加到当前的线程中。如果当前线程没有Runloop，这个方法则走不通的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</div><div class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</div></pre></td></tr></table></figure>
<p>另外，还有AFNetworking2.0、NSURLConnection的使用其实都和Runloop有关，AFNetworking2.0希望能在后台线程接收到Delegate回调，单独创建了一条线程，并在这条这个线程中启动了Runloop。但是AFNetworking换成基于<code>NSURLSession</code>之后，并没有看到相关Runloop代码。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有关Runloop的东西其实还有很多，这里只是站在大神的肩膀上，总结下基本的Runloop知识，希望能帮到需要的同学！</p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li><p><a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></p>
</li>
<li><p><a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="external">http://opensource.apple.com/tarballs/CF/</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小结第二篇，来总结下Runloop的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Runloop概述&quot;&gt;&lt;a href=&quot;#Runloop概述&quot; class=&quot;headerlink&quot; title=&quot;Runloop概述&quot;&gt;&lt;/a&gt;Runloop概述&lt;/h3&gt;&lt;p&gt;学过操作系统的同学都知道，一般来说，一条线程只能执行一个任务，当任务结束后，线程就会退出，完成使命。但是，在很多场景中，我们并不想让线程执行完任务就退出，往往，我们需要其保持随时随地听从命令，可以在需要的时候执行任务，不需要的时候处于等待状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function loop() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    initLoop();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    do &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        if(message_hasTask()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            message_execute(get_current_message());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; while (message != quit);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;比如，在手游上，我们需要一个模型来一直监听用户的触摸事件，来对游戏画面进行切换和逻辑判断。这种模型一般都具有相似性。比如：当模型被事件唤醒之后，如何快速地进行响应；当模型处于等待状态时，如何减少资源耗用等等。&lt;/p&gt;
&lt;p&gt;这种模型，在iOS中称作Runloop。Runloop所解决的问题，就是实现一个线程，使得可以随时响应用户的事件，而不退出。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS小结之copy属性</title>
    <link href="http://yoursite.com/2017/06/05/iOS%E5%B0%8F%E7%BB%93%E4%B9%8Bcopy%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/06/05/iOS小结之copy属性/</id>
    <published>2017-06-05T10:21:19.000Z</published>
    <updated>2017-06-11T07:38:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。</p>
</blockquote>
<p>小结第一篇，来总结一下iOS开发中有关copy的知识点。</p>
<h3 id="iOS中，深拷贝和浅拷贝有什么不同？"><a href="#iOS中，深拷贝和浅拷贝有什么不同？" class="headerlink" title="iOS中，深拷贝和浅拷贝有什么不同？"></a>iOS中，深拷贝和浅拷贝有什么不同？</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。</p>
<h4 id="非集合类对象的copy和mutableCopy"><a href="#非集合类对象的copy和mutableCopy" class="headerlink" title="非集合类对象的copy和mutableCopy"></a>非集合类对象的copy和mutableCopy</h4><p>我们对一个NSString属性进行copy和mutableCopy。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *string = @&quot;abc&quot;;</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x1022fe078, 0x7fff5d901a48</div><div class="line">stringCopy: 0x1022fe078, 0x7fff5d901a40</div><div class="line">stringMCopy: 0x608000260240, 0x7fff5d901a38</div></pre></td></tr></table></figure>
<p>可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。</p>
<a id="more"></a>
<p>接下来，我们对NSMutableString进行copy和mutableCopy.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">NSString *stringCopy = [string copy];</div><div class="line">NSMutableString *stringMCopy = [string mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;string: %p, %p&quot;, string, &amp;string);</div><div class="line">NSLog(@&quot;stringCopy: %p, %p&quot;, stringCopy, &amp;stringCopy);</div><div class="line">NSLog(@&quot;stringMCopy: %p, %p&quot;, stringMCopy, &amp;stringMCopy);</div></pre></td></tr></table></figure>
<p>运行之后，我们可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">string: 0x608000264680, 0x7fff5526aa48</div><div class="line">stringCopy: 0xa000000006362613, 0x7fff5526aa40</div><div class="line">stringMCopy: 0x608000264940, 0x7fff5526aa38</div></pre></td></tr></table></figure>
<p>对NSMutableString进行copy操作，其内存地址和指针地址都发生了变化，所以操作是深拷贝，和上面有所不同；进行mutableCopy操作，其内存地址和指针地址也都发生了变化，所以也是深拷贝。</p>
<blockquote>
<p>以上，我们可以得出，在非集合类对象中，对不可变对象进行copy操作，只仅仅是指针复制，进行mutableCopy操作，是内容复制。</p>
<p>对可变对象进行copy和mutableCopy操作，都是内容复制。</p>
</blockquote>
<h4 id="集合类对象的copy和mutableCopy"><a href="#集合类对象的copy和mutableCopy" class="headerlink" title="集合类对象的copy和mutableCopy"></a>集合类对象的copy和mutableCopy</h4><p>我们以NSArray为例，对其进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSArray *array = @[element_01, element_02, element_03];</div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x600000245910, 0x7fff51367a10; array.firstObject: 0x10e898088</div><div class="line">arrayCopy: 0x600000245910, 0x7fff51367a08; arrayCopy.firstObject: 0x10e898088</div><div class="line">arrayMCopy: 0x600000245670, 0x7fff51367a00; arrayMCopy.firstObject: 0x10e898088</div></pre></td></tr></table></figure>
<p>可以发现，规律和非集合类的很像，对NSArray进行copy操作的时候，数组的内存地址没有发生变化，但是进行mutableCopy操作时，其内存地址发生了变化，结论跟非集合类的差不多。</p>
<p>但是，这里的深拷贝和非集合类的深拷贝还是不太一样的，上面我们打印出了数组的第一个元素的内存地址，可以发现，进行mutableCopy操作时，虽然数组内存地址发生了变化，但是数组元素的内存地址并没有发生变化。</p>
<p>这个属于一个特例，我们称它为<strong>单层深复制</strong>。并不是理论上的完全深复制。</p>
<p>接下来，我们以NSMutableArray为例，进行copy和mutableCopy操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSString *element_01 = @&quot;abc&quot;;</div><div class="line">NSString *element_02 = @&quot;def&quot;;</div><div class="line">NSString *element_03 = @&quot;ghi&quot;;</div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithArray:@[element_01, element_02, element_03]];</div><div class="line"></div><div class="line">NSArray *arrayCopy = [array copy];</div><div class="line">NSMutableArray *arrayMCopy = [array mutableCopy];</div><div class="line"></div><div class="line">NSLog(@&quot;array: %p, %p; array.firstObject: %p&quot;, array, &amp;array, array.firstObject);</div><div class="line">NSLog(@&quot;arrayCopy: %p, %p; arrayCopy.firstObject: %p&quot;, arrayCopy, &amp;arrayCopy, arrayCopy.firstObject);</div><div class="line">NSLog(@&quot;arrayMCopy: %p, %p; arrayMCopy.firstObject: %p&quot;, arrayMCopy, &amp;arrayMCopy, arrayMCopy.firstObject);</div></pre></td></tr></table></figure>
<p>运行之后，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">array: 0x6000000460c0, 0x7fff516d3a10; array.firstObject: 0x10e52c088</div><div class="line">arrayCopy: 0x600000046420, 0x7fff516d3a08; arrayCopy.firstObject: 0x10e52c088</div><div class="line">arrayMCopy: 0x600000046000, 0x7fff516d3a00; arrayMCopy.firstObject: 0x10e52c088</div></pre></td></tr></table></figure>
<p>可以看出，对NSMutableArray进行copy和mutableCopy操作，其内存地址都发生了变化，但是，对于数组中的元素，不管是进行的哪种操作，内存地址始终都没有发生变化，所以属于单层深拷贝。</p>
<blockquote>
<p>所以，我们可以得出，对于不可变的集合类对象进行copy操作，只是改变了指针，其内存地址并没有发生变化；进行mutableCopy操作，内存地址发生了变化，但是其中的元素内存地址并没有发生变化。</p>
<p>对于可变集合类对象，不管是进行copy操作还是mutableCopy操作，其内存地址都发生了变化，但是其中的元素内存地址都没有发生变化，属于单层深拷贝。</p>
</blockquote>
<h3 id="为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"><a href="#为什么我们声明NSString-NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？" class="headerlink" title="为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？"></a>为什么我们声明NSString, NSArray或者NSDictionary的时候，经常使用copy关键字，使用strong有什么区别？</h3><p>这种场景，在定义model时出现最多，首先我们先来看看用copy和strong有什么区别？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSString *strStrong;</div><div class="line">@property (nonatomic, copy) NSString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strStrong = string;</div><div class="line">self.strCopy = string;</div><div class="line">NSLog(@&quot;旧strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;旧strCopy: %@&quot;, self.strCopy);</div><div class="line"></div><div class="line">[string appendFormat:@&quot;def&quot;];</div><div class="line">NSLog(@&quot;新strStrong: %@&quot;, self.strStrong);</div><div class="line">NSLog(@&quot;新strCopy: %@&quot;, self.strCopy);</div></pre></td></tr></table></figure>
<p>运行之后，可以发现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">旧strStrong: abc</div><div class="line">旧strCopy: abc</div><div class="line">新strStrong: abcdef</div><div class="line">新strCopy: abc</div></pre></td></tr></table></figure>
<p>可以发现，当将一个可变对象分别赋值给两个使用不同修饰词的属性后，改变可变对象的内容，使用strong修饰的会跟随着改变，但使用copy修饰的没有改变内容。</p>
<p>知道了strong和copy修饰的区别之后，我们来看为什么要用copy？因为属性需要有封装性，当赋值之后，如果改变其值，会打破本有的封装，所以，在日常大部分开发工作中，我们需要使用copy来修饰NSString等。</p>
<p>那么，是不是NSMutableString等这些可变对象是不是也需要copy来修饰呢？答案是千万不要这么干，我们可以测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/********************* test.h **********************/</div><div class="line">@interface test()</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSMutableString *strCopy;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* test.m **********************/</div><div class="line">NSMutableString *string = [NSMutableString stringWithFormat:@&quot;abc&quot;];</div><div class="line">self.strCopy = string;</div><div class="line">[self.strCopy appendString:@&quot;def&quot;];</div></pre></td></tr></table></figure>
<p>运行上面代码，就会发现，在运行到最后一句的时候会崩溃，因为copy是复制出一个不可变的对象，在不可变对象上运行可变对象的方法，就会找不到执行方法，报下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[NSTaggedPointerString appendString:]: unrecognized selector sent to instance 0xa000000006362613&apos;</div></pre></td></tr></table></figure>
<h3 id="自定义对象实现copy"><a href="#自定义对象实现copy" class="headerlink" title="自定义对象实现copy"></a>自定义对象实现copy</h3><p>有时候，我们需要实现自定义的对象进行copy操作，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div></pre></td></tr></table></figure>
<p>但是，一运行我们发现直接崩溃了，报了一下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">reason: &apos;-[CopyModel copyWithZone:]: unrecognized selector sent to instance 0x608000221c60&apos;</div></pre></td></tr></table></figure>
<p>可以看出，自定义对象实现copy操作，需要重写<code>copyWithZone</code>方法，我们修改下代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/********************* CopyModel.h **********************/</div><div class="line">@interface CopyModel : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy) NSString *title;</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* CopyModel.m **********************/</div><div class="line">@implementation CopyModel</div><div class="line"></div><div class="line">- (instancetype)copyWithZone:(NSZone *)zone &#123;</div><div class="line">    CopyModel *copyModel = [[CopyModel allocWithZone:zone] init];</div><div class="line">    copyModel.title = self.title;</div><div class="line">    copyModel.name = self.name;</div><div class="line">    return copyModel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">/********************* ViewController.m **********************/</div><div class="line">CopyModel *model = [[CopyModel alloc] init];</div><div class="line">model.title = @&quot;title&quot;;</div><div class="line">model.name = @&quot;name&quot;;</div><div class="line"></div><div class="line">CopyModel *modelCopy = [model copy];</div><div class="line">NSLog(@&quot;model: %p, %p&quot;, model, &amp;model);</div><div class="line">NSLog(@&quot;modelCopy: %p, %p&quot;, modelCopy, &amp;modelCopy);</div></pre></td></tr></table></figure>
<p>执行之后，可以发现并没有报错，并且copy也成功了。控制台打印如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">model: 0x608000037660, 0x7fff5bd62a48</div><div class="line">modelCopy: 0x60800003afa0, 0x7fff5bd62a40</div></pre></td></tr></table></figure>
<p>说明我们自定义对象copy成功了!</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这是当前遇到的有关copy问题的总结，应该还算挺全的，希望能帮助到需要的同学！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一直都想去写个系列出来，总结出自己在日常开发中遇到过的知识点，时不时的回头看看，温故而知新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小结第一篇，来总结一下iOS开发中有关copy的知识点。&lt;/p&gt;
&lt;h3 id=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;a href=&quot;#iOS中，深拷贝和浅拷贝有什么不同？&quot; class=&quot;headerlink&quot; title=&quot;iOS中，深拷贝和浅拷贝有什么不同？&quot;&gt;&lt;/a&gt;iOS中，深拷贝和浅拷贝有什么不同？&lt;/h3&gt;&lt;h4 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h4&gt;&lt;p&gt;所谓的浅拷贝，就是指只是将对象内存地址多了一个引用，也就是说，拷贝结束之后，两个对象的值不仅相同，而且对象所指的内存地址都是一样的。&lt;/p&gt;
&lt;h4 id=&quot;深拷贝&quot;&gt;&lt;a href=&quot;#深拷贝&quot; class=&quot;headerlink&quot; title=&quot;深拷贝&quot;&gt;&lt;/a&gt;深拷贝&lt;/h4&gt;&lt;p&gt;所谓深拷贝，就是指拷贝一个对象的具体内容，拷贝结束之后，两个对象的值虽然是相同的，但是指向的内存地址是不同的。两个对象之间也互不影响，互不干扰。&lt;/p&gt;
&lt;h4 id=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;a href=&quot;#非集合类对象的copy和mutableCopy&quot; class=&quot;headerlink&quot; title=&quot;非集合类对象的copy和mutableCopy&quot;&gt;&lt;/a&gt;非集合类对象的copy和mutableCopy&lt;/h4&gt;&lt;p&gt;我们对一个NSString属性进行copy和mutableCopy。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSString *string = @&amp;quot;abc&amp;quot;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSString *stringCopy = [string copy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSMutableString *stringMCopy = [string mutableCopy];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;string: %p, %p&amp;quot;, string, &amp;amp;string);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringCopy: %p, %p&amp;quot;, stringCopy, &amp;amp;stringCopy);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSLog(@&amp;quot;stringMCopy: %p, %p&amp;quot;, stringMCopy, &amp;amp;stringMCopy);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行之后，可以发现：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;string: 0x1022fe078, 0x7fff5d901a48&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringCopy: 0x1022fe078, 0x7fff5d901a40&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;stringMCopy: 0x608000260240, 0x7fff5d901a38&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，对NSString进行copy操作，其新对象的内存地址并没有发生变化，改变的只仅仅是指针的地址，但是进行mutableCopy操作，其内存地址已经发生了变化，并且指针地址发生变化。我们将内存地址发生了变化的copy操作，称之为深拷贝，反之，内存地址没有发生了变化，称之为浅拷贝。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS中遍历的总结</title>
    <link href="http://yoursite.com/2017/04/20/iOS%E4%B8%AD%E9%81%8D%E5%8E%86%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/04/20/iOS中遍历的总结/</id>
    <published>2017-04-20T13:15:11.000Z</published>
    <updated>2017-06-11T07:38:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历的种类"><a href="#遍历的种类" class="headerlink" title="遍历的种类"></a>遍历的种类</h3><p>在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：</p>
<h4 id="经典for循环"><a href="#经典for循环" class="headerlink" title="经典for循环"></a>经典for循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (int i = 0; i &lt; iosArray.count; i++) &#123;</div><div class="line">    //处理数组中数据</div><div class="line">    NSLog(@&quot;%@&quot;, iosArray[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="NSEnumerator遍历"><a href="#NSEnumerator遍历" class="headerlink" title="NSEnumerator遍历"></a>NSEnumerator遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历</div><div class="line">// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历</div><div class="line"></div><div class="line">id object;</div><div class="line"></div><div class="line">while ((object = [enumerator nextObject]) != nil) &#123;</div><div class="line">    //处理枚举器中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, object);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="for-in快速遍历"><a href="#for-in快速遍历" class="headerlink" title="for-in快速遍历"></a>for-in快速遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="EnumeratorBlock遍历"><a href="#EnumeratorBlock遍历" class="headerlink" title="EnumeratorBlock遍历"></a>EnumeratorBlock遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;    // 跳出遍历</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>另外，EnumeratorBlock还支持反向遍历，并发遍历，并发遍历可以使用多核的优化，充分利用系统的资源。</p>
<h4 id="反向遍历"><a href="#反向遍历" class="headerlink" title="反向遍历"></a>反向遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">[iosArray enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line">    if ([obj isEqualToString:@&quot;e&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="并发遍历"><a href="#并发遍历" class="headerlink" title="并发遍历"></a>并发遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">NSArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">NSMutableArray *iosMutableArray = [NSMutableArray arrayWithArray:iosArray];</div><div class="line">[iosMutableArray enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString *obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</div><div class="line">    obj = [NSString stringWithFormat:@&quot;_%@&quot;, obj];</div><div class="line">    [iosMutableArray replaceObjectAtIndex:idx withObject:obj];</div><div class="line">    NSLog(@&quot;%@&quot;, obj);</div><div class="line"></div><div class="line">    if ([obj isEqualToString:@&quot;_I&quot;]) &#123;</div><div class="line">        *stop = YES;</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="dispatch-apply遍历"><a href="#dispatch-apply遍历" class="headerlink" title="dispatch_apply遍历"></a>dispatch_apply遍历</h4><p>dispatch_apply类似于for循环，这里需要注意的是，dispatch_apple是同步调用，调用完毕返回结果，并且由于是GCD实现，所以可以使用并发队列或者是串行队列。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">//    dispatch_queue_t queue = dispatch_queue_create(&quot;queue&quot;, DISPATCH_QUEUE_SERIAL); // 串行队列</div><div class="line">dispatch_apply(array.count, queue, ^(size_t i) &#123;</div><div class="line">    Enumerate *enumerate = [array objectAtIndex:i];</div><div class="line">    NSLog(@&quot;number: %ld&quot;, enumerate.number);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="遍历的注意事项"><a href="#遍历的注意事项" class="headerlink" title="遍历的注意事项"></a>遍历的注意事项</h3><h4 id="for循环中不要修改数组"><a href="#for循环中不要修改数组" class="headerlink" title="for循环中不要修改数组"></a>for循环中不要修改数组</h4><p>遍历过程中是不能随便删除遍历的元素的，如果需要删除元素，可以先复制一份出来，比如如下的代码会有问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *iosArray = @[@&quot;a&quot;, @&quot;b&quot;, @&quot;c&quot;, @&quot;d&quot;, @&quot;e&quot;, @&quot;f&quot;, @&quot;g&quot;];</div><div class="line">for (NSString *obj in iosArray) &#123;</div><div class="line">    //处理数组中的数据</div><div class="line">    if([@&quot;e&quot; isEqualTo:obj]) &#123;</div><div class="line">        [iosArray removeObject:obj];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是使用enumerateBlock可以在block内部做removeObject操作，原因应该是和Block的特性有关，<strong>在Block中会保存变量的值，而不会随变量的值的改变而改变</strong>。</p>
<h4 id="遍历的速率"><a href="#遍历的速率" class="headerlink" title="遍历的速率"></a>遍历的速率</h4><p>当数组容量很大的时候，如果只是进行数组遍历的话，使用for-in是最快速的，其次是并发遍历，这个很多人都以为enumerateBlock是最快的。</p>
<h3 id="遍历实践tips"><a href="#遍历实践tips" class="headerlink" title="遍历实践tips"></a>遍历实践tips</h3><h4 id="数组分组"><a href="#数组分组" class="headerlink" title="数组分组"></a>数组分组</h4><p>在开发中，有时需要对数组进行某种情况的分组，比如，一个拥有很多消息模型的数组，我们需要根据消息的创建月份进行分组，那么可以使用下面的方法实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSMutableSet *set=[NSMutableSet set];</div><div class="line">NSArray *array = @[message1, message2, message3, message4, message5, message6, message7];</div><div class="line">__block NSArray *tempDataArray = [NSArray arrayWithArray:array];</div><div class="line">[tempDataArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    [set addObject:obj.month];//利用set不重复的特性,得到有多少组,根据数组中消息的月份属性</div><div class="line">&#125;];</div><div class="line">[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) &#123;//遍历set数组</div><div class="line">    NSPredicate *predicate = [NSPredicate predicateWithFormat:@&quot;SELF.month = %@&quot;, obj];//创建谓词筛选器</div><div class="line">    NSArray *group = [tempDataArray filteredArrayUsingPredicate:predicate];//用数组的过滤方法得到新的数组,在添加的最终的数组</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="倒序遍历"><a href="#倒序遍历" class="headerlink" title="倒序遍历"></a>倒序遍历</h4><p>倒序遍历也很常见，可以使用上面的反向遍历来实现。</p>
<h4 id="set排序"><a href="#set排序" class="headerlink" title="set排序"></a>set排序</h4><p>这个和Emunerate其实没有关系，但是也很实用，我们知道set是无序的，但是有时需要实现有顺序的set，可以使用下面来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//由于set无序，现将set转换成nsarray</div><div class="line">NSArray *sortDescriptor = @[[[NSSortDescriptor alloc] initWithKey:@&quot;self&quot; ascending:NO]];</div><div class="line">NSArray *sortSetArray = [set sortedArrayUsingDescriptors:sortDescriptor];</div></pre></td></tr></table></figure>
<p>其实原理是将set转化成array来实现的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>遍历在我们日常开发中十分常见，根据应用场景，选择合适的遍历方法才是我们需要关系的。这篇文章总结了下遍历的种类和注意事项，希望能帮助到有需要的同学。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;遍历的种类&quot;&gt;&lt;a href=&quot;#遍历的种类&quot; class=&quot;headerlink&quot; title=&quot;遍历的种类&quot;&gt;&lt;/a&gt;遍历的种类&lt;/h3&gt;&lt;p&gt;在iOS开发中，可以使用多种方法进行元素遍历，具体有一下几种：&lt;/p&gt;
&lt;h4 id=&quot;经典for循环&quot;&gt;&lt;a href=&quot;#经典for循环&quot; class=&quot;headerlink&quot; title=&quot;经典for循环&quot;&gt;&lt;/a&gt;经典for循环&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;for (int i = 0; i &amp;lt; iosArray.count; i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理数组中数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, iosArray[i]);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;NSEnumerator遍历&quot;&gt;&lt;a href=&quot;#NSEnumerator遍历&quot; class=&quot;headerlink&quot; title=&quot;NSEnumerator遍历&quot;&gt;&lt;/a&gt;NSEnumerator遍历&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;NSArray *iosArray = @[@&amp;quot;a&amp;quot;, @&amp;quot;b&amp;quot;, @&amp;quot;c&amp;quot;, @&amp;quot;d&amp;quot;, @&amp;quot;e&amp;quot;, @&amp;quot;f&amp;quot;, @&amp;quot;g&amp;quot;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;NSEnumerator *enumerator = [iosArray objectEnumerator];//正向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;// NSEnumerator *enumerator = [iosArray reverseObjectEnumerator];//反向遍历&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;id object;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;while ((object = [enumerator nextObject]) != nil) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    //处理枚举器中的数据&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;, object);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>MQTT协议及推送服务</title>
    <link href="http://yoursite.com/2017/04/02/MQTT%E5%8D%8F%E8%AE%AE%E5%8F%8A%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2017/04/02/MQTT协议及推送服务/</id>
    <published>2017-04-02T13:31:07.000Z</published>
    <updated>2017-06-11T07:38:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MQTT简介"><a href="#MQTT简介" class="headerlink" title="MQTT简介"></a>MQTT简介</h3><p>MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。</p>
<h4 id="MQTT特性"><a href="#MQTT特性" class="headerlink" title="MQTT特性"></a>MQTT特性</h4><p>MQTT具有如下特性：</p>
<ul>
<li>使用发布／订阅消息模式，提供一对多消息发布；</li>
<li>对负载内容屏蔽的消息传输；</li>
<li><p>使用TCP/IP进行网络连接；</p>
<p>  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。</p>
</li>
<li><p>具有三种消息发布服务质量选项；</p>
<ol>
<li>“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；</li>
<li>“至少一次”，可以确保消息收到，但消息可能会重复；</li>
<li>“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。</li>
</ol>
</li>
<li><p>小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；</p>
<p>  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。</p>
</li>
<li><p>通知有关各方客户端异常中断的机制。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="MQTT协议实现方式"><a href="#MQTT协议实现方式" class="headerlink" title="MQTT协议实现方式"></a>MQTT协议实现方式</h4><p><img src="https://itbilu.com/upload/2016/1/9/14523188625918865.png" alt="image"></p>
<p>在MQTT协议中有三种身份：</p>
<ul>
<li>发布者(Publish)。发布者其实是客户端，可以进行发布消息；<ul>
<li>代理(Broker)。代理指的是服务器，比较有名的是eqmtt，当前，你也可以用其他成熟的框架去搭建MQTT服务；</li>
<li>订阅者(Subscribe)。一般指的是客户端，不过，发布者同时也可以是订阅者。</li>
</ul>
</li>
</ul>
<h4 id="MQTT客户端"><a href="#MQTT客户端" class="headerlink" title="MQTT客户端"></a>MQTT客户端</h4><p>一般来说，客户端可以实现一下功能：</p>
<ul>
<li>给其他客户端发布订阅的信息；</li>
<li>订阅其他客户端发布的信息；</li>
<li>退订和订阅主题；</li>
<li>断开服务器连接。</li>
</ul>
<h4 id="MQTT服务端"><a href="#MQTT服务端" class="headerlink" title="MQTT服务端"></a>MQTT服务端</h4><p>MQTT服务端也称为消息代理，经常你会听到broker这个词。它可以实现一下功能：</p>
<ul>
<li>接收来自客户端的网络连接；</li>
<li>接受客户发布的应用信息；</li>
<li>处理来自客户端主题订阅和退订请求；</li>
<li>向订阅的客户端转发应用程序消息。</li>
</ul>
<h4 id="MQTT协议中的方法"><a href="#MQTT协议中的方法" class="headerlink" title="MQTT协议中的方法"></a>MQTT协议中的方法</h4><p>MQTT和HTTP一样，也定义了一些动作，来表示对确定资源进行操作。</p>
<ul>
<li><strong>Connect</strong>，等待于服务器建立连接；</li>
<li><strong>Disconnect</strong>，等待客户端完成所做的工作，并与服务器断开TCP/IP会话；</li>
<li><strong>Subscribe</strong>，主题订阅；</li>
<li><strong>UnSubscribe</strong>，主题取消订阅；</li>
<li><strong>Publish</strong>，发送消息。</li>
</ul>
<h3 id="移动端推送服务"><a href="#移动端推送服务" class="headerlink" title="移动端推送服务"></a>移动端推送服务</h3><p>消息推送服务目前已经是app开发中必备的一个功能了，及时地将消息推送给用户，可以使得用户不会错过重大新闻或者重要事件通知。一般，推送服务有三种实现方式：</p>
<ol>
<li>轮询方式。客户端不断的查询服务器，检索新内容。这种方式的缺点十分明显，如果轮询频率过快，会大量消耗网络带宽和电池；</li>
<li>长连接方式。客户端和服务端维持一条TCP/IP长连接，服务端向客户端push数据。这种方式可以避免轮询方式带来的性能问题，但是长连接依然会带来耗能问题。目前苹果的APNS和谷歌的GCM都是基于此方案来实现推送服务的；</li>
<li>SMS方式。当服务端有新内容的时候，会发送一条类似短信的指令传给客户端，客户端收到后从服务端下载新内容。由于运营商并没有免费开放这种指令，使用需要向运营商缴纳部分费用，所以并没有大量运用起来，但是这种方式非常的高效和及时。</li>
</ol>
<h4 id="iOS和Andorid推送的实现差异"><a href="#iOS和Andorid推送的实现差异" class="headerlink" title="iOS和Andorid推送的实现差异"></a>iOS和Andorid推送的实现差异</h4><p>之前我们说过，目前移动端的推送服务实现都是基于长连接方式实现的。服务端和客户端之间需要存在一条长连接来维持，当服务端主动推送内容给客户端时，客户端可以接收到该内容。</p>
<p><strong>iOS推送服务</strong></p>
<p>在iOS系统中，这个长连接是由系统去维护，iOS上所有应用的推送都是先将推送推到苹果推送服务器(APNs)上，应用需要推送功能时，需要先注册推送服务。其流程图如下所示：</p>
<p><img src="https://pic4.zhimg.com/f74c97ee64f0bf008e8c790206811f4f_b.png" alt="推送注册流程图"></p>
<p>首先，苹果会下发deviceToken，这是APNs推送实现的基础。APNs推送能够实现就是基于deviceToken来推送的，只有正确的deviceToken才会被APNs接受，一般第三方推送商就是来收集deviceToken来进行推送的。</p>
<p>当开始进行推送内容的时候，服务端会将内容先推到APNs，然后，剩下的就都交给APNs去做了，其推送内容流程如下：</p>
<p><img src="https://pic2.zhimg.com/4525ca70963895ab4fca064a537dbcd9_b.png" alt="推送注册流程图"></p>
<p>苹果这么做，不管是给用户还是开发者，带来的好处都是实实在在的：</p>
<ol>
<li>由于是系统级别的长连接，所以不会出现被杀死而不发推送的现象；</li>
<li>省电。不用每个app都去各自维护一个自己的长连接；</li>
<li>安全可靠。为了能够使用推送服务，必须先在开发者账号注册推送功能，这就大大降低了长连接滥用的场景。</li>
<li>对于开发来说，实现起来十分容易，服务端只要将正确的deviceToken和推送内容发送给APNs，然后客户端进行推送注册和逻辑处理就行了。</li>
</ol>
<p><strong>Android推送服务</strong></p>
<p>Android系统上，Google也推出了和APNS类似的服务，叫做GCM。但是由于国情原因(你懂得)，导致该服务在中国无法使用。所以，国内Andorid的普遍做法是自己维护一条长连接，和自己的推送服务器或者第三方推送商对接。</p>
<p>其实现原理APNs没有本质区别，但是由于一个设备通常需要维持多个长连接，所以在耗能这块，Andorid这块处理就不尽人意，并且，由于后台可以常驻，所以安全性这块也得不到保障。</p>
<p>除了类似APNs的实现，在Android上，也可以采用轮询方式，也可以简单实现推送功能。</p>
<h3 id="MQTT实现消息推送"><a href="#MQTT实现消息推送" class="headerlink" title="MQTT实现消息推送"></a>MQTT实现消息推送</h3><h4 id="iOS端实现"><a href="#iOS端实现" class="headerlink" title="iOS端实现"></a>iOS端实现</h4><p>对于iOS端使用MQTT来实现消息推送服务，比较常见的做法就是采用离线消息的方式去做，服务端发送推送消息，发送到APNs上，然后APNs通知客户端收到通知消息，客户端去服务端拉取最新消息列表，然后展示的界面上并处理相关逻辑。</p>
<h4 id="Android端实现"><a href="#Android端实现" class="headerlink" title="Android端实现"></a>Android端实现</h4><p>由于并不是做Android开发，并且Android方面采用方式五花八门，了解的做法是类似iOS的实现，利用MQTT将服务端和客户端建议一个长连接，然后服务端将消息直接推倒客户端上，客户端收到推送消息后，去服务端拉取最新的消息列表。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于移动设备来说，MQTT以低开销、低带宽著称，十分适合搭建推送服务。目前方案也比较成熟，希望未来MQTT的应用会越来越广！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MQTT简介&quot;&gt;&lt;a href=&quot;#MQTT简介&quot; class=&quot;headerlink&quot; title=&quot;MQTT简介&quot;&gt;&lt;/a&gt;MQTT简介&lt;/h3&gt;&lt;p&gt;MQTT全称叫做Message Queuing Telemetry Transport，意为消息队列遥测传输，是IBM开发的一个即时通讯协议。由于其维护一个长连接以轻量级低消耗著称，所以常用于移动端消息推送服务开发。&lt;/p&gt;
&lt;h4 id=&quot;MQTT特性&quot;&gt;&lt;a href=&quot;#MQTT特性&quot; class=&quot;headerlink&quot; title=&quot;MQTT特性&quot;&gt;&lt;/a&gt;MQTT特性&lt;/h4&gt;&lt;p&gt;MQTT具有如下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用发布／订阅消息模式，提供一对多消息发布；&lt;/li&gt;
&lt;li&gt;对负载内容屏蔽的消息传输；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用TCP/IP进行网络连接；&lt;/p&gt;
&lt;p&gt;  主流的MQTT是基于TCP进行连接的，同样也有UDP版本的MQTT，但是不太常用，叫做MQTT-SN。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具有三种消息发布服务质量选项；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“至多一次”，通常app的推送使用的就是这种模式。也就是说，如果移动设备在消息推送的时候没有联网，那么再次联网就不会收到通知了；&lt;/li&gt;
&lt;li&gt;“至少一次”，可以确保消息收到，但消息可能会重复；&lt;/li&gt;
&lt;li&gt;“只有一次”，确保消息到达一次，比如计费系统， 如果出现消息重复或者丢失会导致系统结果不正确的问题。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;小型传输，开销很小（固定长度的头部是2字节），协议交换最小化，以降低网络流量；&lt;/p&gt;
&lt;p&gt;  这就是为什么MQTT能以轻量级低消耗著称，所以MQTT特别适用于低开销、低宽带占用的即时通讯场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通知有关各方客户端异常中断的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>有关Keychain服务，你需要了解这些</title>
    <link href="http://yoursite.com/2017/02/20/%E6%9C%89%E5%85%B3Keychain%E6%9C%8D%E5%8A%A1%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E8%BF%99%E4%BA%9B/"/>
    <id>http://yoursite.com/2017/02/20/有关Keychain服务，你需要了解这些/</id>
    <published>2017-02-20T06:15:44.000Z</published>
    <updated>2017-06-11T07:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。</p>
</blockquote>
<h3 id="NSUserDefaults不安全"><a href="#NSUserDefaults不安全" class="headerlink" title="NSUserDefaults不安全"></a>NSUserDefaults不安全</h3><p>NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。</p>
<p>当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。</p>
<p>所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。</p>
<a id="more"></a>
<h3 id="Keychain使用场景"><a href="#Keychain使用场景" class="headerlink" title="Keychain使用场景"></a>Keychain使用场景</h3><h4 id="存储隐私信息"><a href="#存储隐私信息" class="headerlink" title="存储隐私信息"></a>存储隐私信息</h4><p>在iOS系统中，最常用的keychain服务就是存储用户密码了。使用keychain保存用户密码最大的好处已经在上面说过，个人极力推荐这么做。</p>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>如果我们有多个app，它们之间需要共享一些数据，以提供更好的用户体验，那么使用Keychain群组可以实现。但前提是同一个公司的产品才能共享，比如<code>com.hyyy.test1</code>和<code>com.hyyy.test2</code>两个同一公司下的不同产品之前可以实现数据共享。</p>
<h4 id="设备唯一标示存储"><a href="#设备唯一标示存储" class="headerlink" title="设备唯一标示存储"></a>设备唯一标示存储</h4><p>在iOS中，为了在苹果的打压下获取唯一标示符，开发者们也是想尽了办法，目前最好的方式就是获取IDFV，并将其存储到keychain中。IDFV是设备区别应用提供商的，一般来说可以作为应用唯一标示符。但是IDFV缺陷就是当设备删除了该所有应用提供商的app之后，IDFV值会发生变化，所以IDFV+Keychain的组合目前被经常用到，来替代UDID的作用。特别是加上Keychain的共享服务，可以使应用提供商下的所有app下获取的IDFV都不会发生变化。这一服务可以说是目前最佳的识别用户的办法。</p>
<h4 id="其他用处"><a href="#其他用处" class="headerlink" title="其他用处"></a>其他用处</h4><p>当然，不同app的需求是不一样的，如果你需要存储一些信息，即使app删掉后也不会丢失，那么使用Keychain服务可以完美地实现这点。</p>
<h3 id="实践总结"><a href="#实践总结" class="headerlink" title="实践总结"></a>实践总结</h3><p>其实，所有的这些都是本人摸索出来的，并且实现了一个Swift3下的简单Keychain工具，叫<a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>。这个框架是参考大名鼎鼎的<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>和苹果官方的GenericKeychain实现的，如果您的Swfit项目需要使用到Keychain，希望这个可以帮到您，HYKeychainHelper操作起来也比较简单，如果您之前使用过SAMKeychain的话，那更容易了。</p>
<p><a href="https://github.com/castial/HYKeychainHelper" target="_blank" rel="external">HYKeychainHelper</a>的用法也比较简单，为了更好上手，语法采用和<a href="https://github.com/soffes/SAMKeychain" target="_blank" rel="external">SAMKeychain</a>基本一致。具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/// query account&apos;s password</div><div class="line"></div><div class="line">HYKeychainHelper.password(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// add or update an account</div><div class="line"></div><div class="line">HYKeychainHelper.set(password: &quot;your_password&quot;, service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// delete an account</div><div class="line"></div><div class="line">HYKeychainHelper.deletePassword(service: &quot;your_service_name&quot;, account: &quot;your_account_name&quot;)</div><div class="line"></div><div class="line">/// all accounts</div><div class="line"></div><div class="line">HYKeychainHelper.allAccounts(forService: &quot;your_service_name&quot;)</div></pre></td></tr></table></figure>
<blockquote>
<p>对于更多的用法，请查看HYKeychainHelper获取更多细节。</p>
</blockquote>
<p>另外，对Keychain的了解难免有些遗漏，如果对Keychain有更多的看法，欢迎留言给我，对自己来说也是一种收获！</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS系统中，Keychain提供了安全的存储服务，用来存储一些敏感信息。但是在日常开发中，我们经常会忽视这个苹果自荐的功能，本文的目的就是引起开发者的重视，敏感信息尽量使用Keychain服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NSUserDefaults不安全&quot;&gt;&lt;a href=&quot;#NSUserDefaults不安全&quot; class=&quot;headerlink&quot; title=&quot;NSUserDefaults不安全&quot;&gt;&lt;/a&gt;NSUserDefaults不安全&lt;/h3&gt;&lt;p&gt;NSUserDefaults其实是plist文件中键值存储，并且最大的问题是存在与沙盒中，这就对安全性埋下了隐患。如果攻击者破解app，拿到了沙盒中的数据，就会造成数据泄漏，后果不堪设想。&lt;/p&gt;
&lt;p&gt;当然，一般也不会有把密码直接使用NSUserDefaults存储的，都会进行加密、或者是多重加密后再进行NSUserDefaults存储。这么做其实是可行的，前提是加密算法不能泄漏。有个小问题就是，如果用户删掉app重装的话，之前所有存储的敏感信息都会消失。比如，一个用户误删了使用NSUserDefaults存储密码的app，当重新安装之后，由于以前是记住密码免登录，只因为自己操作不当，接下来要进入找回密码功能，重新修改密码才能再次使用app。这对用户来说是一种相当不友好的体验。&lt;/p&gt;
&lt;p&gt;所以，正确的姿势是使用Keychain服务来存储。Keychain保存的数据不仅仅是加密过的，而且由于Keychain是存在与沙盒之外的，当应用删除之后，app存储的数据并没有被删掉，第二次安装时只要读取Keychain里的数据，即可得到以前存储的信息。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>浅谈iOS事件机制</title>
    <link href="http://yoursite.com/2016/12/10/%E6%B5%85%E8%B0%88iOS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2016/12/10/浅谈iOS事件机制/</id>
    <published>2016-12-10T08:04:20.000Z</published>
    <updated>2017-07-12T08:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。</p>
</blockquote>
<h3 id="iOS中的事件"><a href="#iOS中的事件" class="headerlink" title="iOS中的事件"></a>iOS中的事件</h3><p>在iOS中事件分为3类：</p>
<ul>
<li>Touch Events(触摸事件。包括单击、双击等)；</li>
<li>Motion Events(重力感应、晃动手机等等)；</li>
<li>Remote Events(远程事件，比如耳机音量按键的触发)。</li>
</ul>
<p>不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。</p>
<h3 id="事件的产生"><a href="#事件的产生" class="headerlink" title="事件的产生"></a>事件的产生</h3><p>在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。</p>
<p><code>UIResponder</code>并不是一个视图，是继承<code>NSObject</code>的一个对象。</p>
<a id="more"></a>
<p>我们先看下<code>UIResponder</code>对外暴露的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder : NSObject &lt;UIResponderStandardEditActions&gt;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly, nullable) UIResponder *nextResponder;</div><div class="line">#else</div><div class="line">- (nullable UIResponder*)nextResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canBecomeFirstResponder;    // default is NO</div><div class="line">#else</div><div class="line">- (BOOL)canBecomeFirstResponder;    // default is NO</div><div class="line">#endif</div><div class="line">- (BOOL)becomeFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL canResignFirstResponder;    // default is YES</div><div class="line">#else</div><div class="line">- (BOOL)canResignFirstResponder;    // default is YES</div><div class="line">#endif</div><div class="line">- (BOOL)resignFirstResponder;</div><div class="line"></div><div class="line">#if UIKIT_DEFINE_AS_PROPERTIES</div><div class="line">@property(nonatomic, readonly) BOOL isFirstResponder;</div><div class="line">#else</div><div class="line">- (BOOL)isFirstResponder;</div><div class="line">#endif</div><div class="line"></div><div class="line">// Generally, all responders which do custom touch handling should override all four of these methods.</div><div class="line">// Your responder will receive either touchesEnded:withEvent: or touchesCancelled:withEvent: for each</div><div class="line">// touch it is handling (those touches it received in touchesBegan:withEvent:).</div><div class="line">// *** You must handle cancelled touches to ensure correct behavior in your application.  Failure to</div><div class="line">// do so is very likely to lead to incorrect behavior or crashes.</div><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event;</div><div class="line">- (void)touchesEstimatedPropertiesUpdated:(NSSet&lt;UITouch *&gt; *)touches NS_AVAILABLE_IOS(9_1);</div></pre></td></tr></table></figure>
<p>可以说<code>UIResponder</code>是所有可以响应事件的基类，包括<code>UIView</code>、<code>UIViewController</code>、<code>UIWindow</code>和<code>UIApplication</code>。我们可以看下这些类的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// UIView.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIView : UIResponder</div><div class="line"></div><div class="line">// UIViewController.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIViewController : UIResponder</div><div class="line"></div><div class="line">// UIWindow.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIWindow : UIView</div><div class="line"></div><div class="line">// UIApplication.h</div><div class="line">NS_CLASS_AVAILABLE_IOS(2_0) @interface UIApplication : UIResponder</div></pre></td></tr></table></figure>
<p>可以看到，都继承自<code>UIResponder</code>。可以看出，事件响应的产生来自<code>UIResponder</code>，并且系统会自动调用，除了自定义需求。</p>
<p>比如在自定义的<code>UIView</code>子类中，重写下面的四个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesBegan触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesEnded触发&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    // 某个系统事件打断触摸过程，系统会自动调用这个方法，比如电话接入等。</div><div class="line">    NSLog(@&quot;UITestView=====touchesCancelled触发&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你会发现，当在这个view上做点击、滑动操作时，会触发某些方法的调用。我们可以在这里处理view的触摸事件。比如我们需要实现自定义view可以进行拖拽，那么可以在<code>touchesMoved</code>方法里做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</div><div class="line">    NSLog(@&quot;UITestView=====touchesMoved触发&quot;);</div><div class="line"></div><div class="line">    UITouch *touch = [touches anyObject];</div><div class="line"></div><div class="line">    CGPoint currentPoint = [touch locationInView:self];</div><div class="line">    CGPoint previousPoint = [touch previousLocationInView:self];</div><div class="line"></div><div class="line">    CGFloat offsetX = currentPoint.x - previousPoint.x;</div><div class="line">    CGFloat offsetY = currentPoint.y - previousPoint.y;</div><div class="line"></div><div class="line">    self.transform = CGAffineTransformTranslate(self.transform, offsetX, offsetY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>好了，我们来总结一下事件响应的产生，从系统底层开始。</p>
<ol>
<li>iOS基于Runloop，其实注册了一个Source1用来接收系统事件；</li>
<li>当手机硬件发生变化，比如触摸、摇晃等，首先通过系统IO来生成一个Event，然后转发给需要的App进程，这时候上面注册的Source1就会触发；</li>
<li>在Source1回调中，会触发Source0，Source0会对Event进行处理，对该Event进行内部分发，并封装成UIEvent，这时候就会调用基本的UIResponder方法；</li>
<li>UIEvent会传递给touchesBegin/Move/End/Cancel，或者<code>UIButton</code>点击等，这些方法会被执行。</li>
</ol>
<h3 id="事件响应传递"><a href="#事件响应传递" class="headerlink" title="事件响应传递"></a>事件响应传递</h3><p>在iOS视图组成中，可以看到其实是一个树状结构，如下图：</p>
<p><img src="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Art/view_hierarchy_enclose.jpg" alt="image"></p>
<p>事件响应的传递，其实是参照视图结构，从父控件到子控件这样一个顺序来做的，也就是UIApplication-&gt;UIWindow-&gt;superView-&gt;subView，如果父控件不能接收UIEvent事件，那么其下的子控件肯定不能接收到UIEvent事件。</p>
<p>不过在传递的过程中，如果遇到：</p>
<ol>
<li>该视图不允许交互(userInteractionEnabled = NO);</li>
<li>该视图hidden是YES;</li>
<li>该视图透明度在0~0.01之间。</li>
</ol>
<p>以上三种情况任意一种，该视图都接收不到Touch事件。</p>
<h4 id="如何找到合适的view"><a href="#如何找到合适的view" class="headerlink" title="如何找到合适的view"></a>如何找到合适的view</h4><p>当用户点击屏幕后，系统就会生成一个UIEvent对象，这个事件会放在事件队列中，当处理对象的时候，UIApplication对象会从队列取出UIEvent对象，然后进行分发，以UIApplication-&gt;UIWindow-&gt;superView-&gt;subView的顺序来。具体顺序如下：</p>
<ol>
<li>首先判断主窗口可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上；</li>
<li>遍历自己的子控件，看子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>重复上一步操作，判断子控件的子控件可不可以接收触摸事件，如果可以，判断触摸点在不在自己身上，然后将触摸事件传递给子控件；</li>
<li>循环遍历之后，如果最后没有发现合适的子控件，那么其本身就是合适的view。</li>
</ol>
<p>另外，这里涉及到两个两个重要的传递方法，分别是：</p>
<ul>
<li><code>hitTest:withEvent:</code>;</li>
<li><code>pointInside</code>。</li>
</ul>
<p>我们一个一个来说。</p>
<h4 id="hitTest-withEvent"><a href="#hitTest-withEvent" class="headerlink" title="hitTest:withEvent:"></a>hitTest:withEvent:</h4><p><code>hitTest:withEvent:</code>是做事件传递的，下面简称<code>hit-Test</code>。当手指触摸屏幕，发生触摸事件，该UIEvent对象的传递顺序如下所示：</p>
<blockquote>
<p>发生触摸事件 -&gt; 生成UIEvent对象 -&gt; UIWindow hit-Test方法触发 -&gt; superView hit-Test方法触发 -&gt; subView hit-Test方法触发 -&gt; 返回合适的view。</p>
</blockquote>
<p>事件传递给主窗口后，主窗口会将事件往下传递，然后才会在自身查找合适的view。需要注意的是事件传递给window和view后，就会调用hit-Test方法，所以是先将事件传递给子控件，子控件调用hit-Test方法验证自己有没有合适的View，如果父控件是最合适的view，那子控件的hit-Test还是会走的，这里需要注意一下的。</p>
<p>有时候我们需要重写hit-Test，来改变最适合的view，那么请记住修改规则，需要谁成为最合适的view，就重写其父视图的hit-Test方法。</p>
<p>另外，如果去验证问题的话就会发现，每次hit-Test方法会走两次，根据苹果官方的回应，这个是正常的，不用去管。</p>
<h4 id="pointInside"><a href="#pointInside" class="headerlink" title="pointInside"></a>pointInside</h4><p><code>pointInside</code>方法是用来判断触摸点在不在当前view上，如果返回YES，说明在其坐标上；返回NO，说明不在其坐标上。一般和hit-Test方法是成对出现的。</p>
<p>这个方法也比较好理解，需要注意的事，和hit-Test类似，也是会调用两次的。</p>
<p>另外，这两个方法的调用，都是在<code>touchesBegan</code>、<code>touchesMoved</code>、<code>touchesEnded</code>之前发生的，这是因为touch事件的发生，是在已确认合适的view后发生的，所以才会是这样。</p>
<h3 id="事件机制应用"><a href="#事件机制应用" class="headerlink" title="事件机制应用"></a>事件机制应用</h3><p>对于事件机制的应用，网上已经很多，接下来只说下自己经常用到的场景，其实原理都是一样的。</p>
<h4 id="查看当前的触摸点"><a href="#查看当前的触摸点" class="headerlink" title="查看当前的触摸点"></a>查看当前的触摸点</h4><p>在日常开发调试中，有时候需要时时去监听当前点击的坐标值。我们可以重写系统<code>UIApplication</code>的<code>sendEvent</code>方法，来实现此操作。</p>
<p>首先我们继承<code>UIApplication</code>实现一个子类，名为<code>HYApplication</code>，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation HYApplication</div><div class="line"></div><div class="line">- (void)sendEvent:(UIEvent *)event &#123;</div><div class="line">    [super sendEvent:event];</div><div class="line"></div><div class="line">    if (event.type == UIEventTypeTouches) &#123;</div><div class="line">        if ([[event.allTouches anyObject] phase] == UITouchPhaseBegan) &#123;</div><div class="line">            // 打印出来屏幕触摸坐标</div><div class="line">            CGPoint point = [[event.allTouches anyObject] locationInView:[self mainWindow]];</div><div class="line">            NSLog(@&quot;touching point: %@&quot;, NSStringFromCGPoint(point));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - Private Methods</div><div class="line">// 获取主窗口</div><div class="line">- (UIWindow *)mainWindow &#123;</div><div class="line">    if ([UIApplication sharedApplication].delegate.window) &#123;</div><div class="line">        return [UIApplication sharedApplication].delegate.window;</div><div class="line">    &#125;else &#123;</div><div class="line">        return [UIApplication sharedApplication].windows[0];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>重写<code>UIApplication</code>的<code>sendEvent</code>方法，进行简单改造，然后修改程序入口main函数，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;HYApplication.h&quot;</div><div class="line"></div><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, NSStringFromClass([HYApplication class]), NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>HYApplication</code>添加进去，运行程序，点击任意位置都会打印出坐标了，是不是很方便呢。</p>
<p>其实这里还可以实现其他操作，原理都是一样的。</p>
<h4 id="扩大UIButton的点击区域"><a href="#扩大UIButton的点击区域" class="headerlink" title="扩大UIButton的点击区域"></a>扩大UIButton的点击区域</h4><p>有时候给的设计图上，一个按钮图标会很小，点击区域很小，有时候很别扭。这时候我们就可以重写<code>pointInside</code>方法来实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    BOOL isInside = CGRectContainsPoint(HitTestingBounds(self.bounds, CGRectGetWidth(self.bounds) + 50, CGRectGetHeight(self.bounds) + 50), point);</div><div class="line">    return isInside;</div><div class="line">&#125;</div><div class="line"></div><div class="line">CGRect HitTestingBounds(CGRect bounds, CGFloat minimumHitTestWidth, CGFloat minimumHitTestHeight) &#123;</div><div class="line">    CGRect hitTestingBounds = bounds;</div><div class="line">    if (minimumHitTestWidth &gt; bounds.size.width) &#123;</div><div class="line">        hitTestingBounds.size.width = minimumHitTestWidth;</div><div class="line">        hitTestingBounds.origin.x -= (hitTestingBounds.size.width - bounds.size.width)/2;</div><div class="line">    &#125;</div><div class="line">    if (minimumHitTestHeight &gt; bounds.size.height) &#123;</div><div class="line">        hitTestingBounds.size.height = minimumHitTestHeight;</div><div class="line">        hitTestingBounds.origin.y -= (hitTestingBounds.size.height - bounds.size.height)/2;</div><div class="line">    &#125;</div><div class="line">    return hitTestingBounds;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样以来，我们把范围扩大到+50的范围，使得点击起来不在那么别扭。</p>
<h4 id="UIResponder分类"><a href="#UIResponder分类" class="headerlink" title="UIResponder分类"></a>UIResponder分类</h4><p>这个最早是在环信的Demo里看到的，个人觉得还是挺好用。是实现了一个<code>UIResponder</code>的category。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface UIResponder (AppResponse)</div><div class="line"></div><div class="line">/**</div><div class="line"> 事件路由，层级传递</div><div class="line"></div><div class="line"> @param eventName 事件名</div><div class="line"> @param userInfo 携带信息</div><div class="line"> */</div><div class="line">-(void)routerEvent:(NSString *)eventName userInfo:(id)userInfo;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation UIResponder (AppResponse)</div><div class="line"></div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    [[self nextResponder] routerEvent:eventName userInfo:userInfo];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>一个简单的category，对外暴露了一个方法，用来传递事件。正常开发中，我们传递事件一般都是用delegate或者block去做，比如我们需要从view里传递一个事件到controller层，如果有了这个category，可以这么做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// view层添加一个点击事件，然后事件方法内部调用routerEvent实现事件传递。</div><div class="line">- (void)clickedBtnHandler &#123;</div><div class="line">    [self routerEvent:@&quot;clicked_btn&quot; userInfo:param];</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 然后在controller层监听这个方法，然后在回调里处理相关逻辑。</div><div class="line">- (void)routerEvent:(NSString *)eventName userInfo:(id)userInfo &#123;</div><div class="line">    if ([@&quot;clicked_btn&quot; isEqualStirng:eventName]) &#123;</div><div class="line">        // 拿到获取到的userInfo，来处理点击后的事件。</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样可以使得点击事件和回调有个统一的出发点和着陆点，代码比较好管理，易读。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于iOS的事件机制，就说到这里。事件机制代表了我们使用iOS系统的所有操作出发点，也是比较重要的，这块还需要多多理解。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS的交互逻辑中，我们做的最多的是事件处理，今天我们就浅谈学习下iOS的事件传递机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;iOS中的事件&quot;&gt;&lt;a href=&quot;#iOS中的事件&quot; class=&quot;headerlink&quot; title=&quot;iOS中的事件&quot;&gt;&lt;/a&gt;iOS中的事件&lt;/h3&gt;&lt;p&gt;在iOS中事件分为3类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Touch Events(触摸事件。包括单击、双击等)；&lt;/li&gt;
&lt;li&gt;Motion Events(重力感应、晃动手机等等)；&lt;/li&gt;
&lt;li&gt;Remote Events(远程事件，比如耳机音量按键的触发)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过我们一般接触的Touch Events是最多的，其他两个就不多过介绍了，主要学习下Touch Events。&lt;/p&gt;
&lt;h3 id=&quot;事件的产生&quot;&gt;&lt;a href=&quot;#事件的产生&quot; class=&quot;headerlink&quot; title=&quot;事件的产生&quot;&gt;&lt;/a&gt;事件的产生&lt;/h3&gt;&lt;p&gt;在iOS中看到的UIButton可以点击，UIScrollView可以滑动，其实最根本的是UIResponder对象来实现的，只有继承了UIResponder，才能接收并处理事件响应。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;UIResponder&lt;/code&gt;并不是一个视图，是继承&lt;code&gt;NSObject&lt;/code&gt;的一个对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
