<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Swift之自动引用计数 · Hyyy的技术博客</title><meta name="description" content="Swift之自动引用计数 - Hyyy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hyyy的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">博客</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="http://www.jianshu.com/u/eee3fae14bec" target="_blank" class="nav-list-link">简书</a></li><li class="nav-list-item"><a href="https://github.com/castial" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Swift之自动引用计数</h1><div class="post-info">Apr 5, 2016</div><div class="post-content"><blockquote>
<p>这个概念并不是Swift专有，在Objective-C中就已经运用广泛。运用这种机制，能很好地跟踪和管理应用程序的内存。  </p>
</blockquote>
<p>在早期，Apple一直使用的是MRC，这篇文章并不想讲解MRC，使用MRC时，Swift还没有诞生呢。MRC是手动管理内存的，比如创建一个实例对象，如果需要释放该对象，是需要手动去释放的。而使用ARC的好处是，ARC可以自动的帮您管理内存，自动释放其占有的内存。  </p>
<p>特别注意：不管是ARC还是MRC，引用计数只仅仅应用于类的实例，不能应用于结构体和枚举类型。  </p>
<h3 id="自动引用计数原理"><a href="#自动引用计数原理" class="headerlink" title="自动引用计数原理"></a>自动引用计数原理</h3><p>首先记住，每创建一个新的实例，ARC会自动分配给一块内存用来存储实例的信息，当内存不再使用时，ARC会释放实例所占的内存，供其他实例使用。  </p>
<p>为了分辨实例是否正在处于使用的情况，ARC会跟踪和计算每一个实例的引用次数，如果实例的引用次数小于1，那么ARC会销毁这个实例。  </p>
<p>下面给出一个例子，用来解释ARC的运行机制，我们先实现一个Person类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Person类很简单，有一个名为name的属性，然后重写<code>init</code>和<code>deinit</code>方法。然后我们定义三个变量来对Person类进行引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person1: Person?</div><div class="line">var person2: Person?</div><div class="line">var person3: Person?</div></pre></td></tr></table></figure>
<p>可选选项可以保证在没实例化之前是nil。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">person1 = Person(name: &quot;Jack&quot;)</div><div class="line">person2 = person1</div><div class="line">person3 = person1</div></pre></td></tr></table></figure>
<p>当我们对person1执行实例化时，会打印出<code>Jack正在被初始化</code>，说明Person实例赋值给了person1，需要注意的是，两者之间是建立了一个强引用，强引用可以保证Person实例可以保持在内存中不被销毁。将同一个实例也赋值给person2和person3，又回多出两个强引用，所以现在Person实例有三个强引用。  </p>
<p>接下来我们通过赋值<code>nil</code>来断开强引用关系。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">person1 = nil</div><div class="line">person2 = nil</div></pre></td></tr></table></figure>
<p>然后我们断开person3的强引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">person3 = nil</div></pre></td></tr></table></figure>
<p>这时我们发现，Console中打印出了<code>Jack正在被销毁</code>的log。所以说明，当一个实例不再有强引用关系时，ARC会自动销毁存在在内存中的该实例，释放内存供其他实例使用。</p>
<a id="more"></a>
<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p>这个问题发生的原因很简单，就是使用ARC的话，我们会发现有时候引用计数永远也不会为0，两个类之间互相持有对方的强引用，这就是所谓的循环强引用问题。  </p>
<p>我们先来看看强引用是怎么产生的，首先定义两个类，Person和Apartment，代表人和公寓两个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    let name: String</div><div class="line">    var apartment: Apartment?</div><div class="line"></div><div class="line">    init(name: String) &#123;</div><div class="line">        self.name = name</div><div class="line">        print(&quot;\(name)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(name)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之所以要将变量定义成可选的，是因为不是每个人都有公寓的，类似的，不是每个公寓都有人住，所以符合现实需求。  </p>
<p>然后我们定义两个变量，分别对Person和Apartment的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var per: Person?</div><div class="line">var apart: Apartment?</div><div class="line"></div><div class="line">per = Person(name: &quot;Jack&quot;)</div><div class="line">apart = Apartment(unit: &quot;4A&quot;)</div></pre></td></tr></table></figure>
<p>注意，对于对象的引用为强引用。但是如何实现人住进公寓，公寓里有人呢，来看看实现方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per!.apartment = apart</div><div class="line">apart!.person = per</div></pre></td></tr></table></figure>
<p>现在，实现了上面所说的功能，但是不幸的是，这里会造成一个循环引用，Person实例有一个指向Apartment实例的引用，而Apartment实例有一个指向Person实例的引用。这时，像上面的处理一样，我们把变量设为<code>nil</code>。看会不会销毁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有打印销毁log，说明Person和Apartment实例之间的强引用保留了下来并不会断开。这就是我们常说的循环引用。</p>
<h3 id="循环引用解决办法"><a href="#循环引用解决办法" class="headerlink" title="循环引用解决办法"></a>循环引用解决办法</h3><p>以前在Objective-C中，如果出现了循环引用，那么使用<code>weak</code>可以解决问题，那在Swift中一样，只不过在Swift中有两种解决办法，一种是weak，另外一种是unowned。  </p>
<p>两者的解决办法都相似，就是允许一个实例引用另外一个实例但不保持强引用。  </p>
<h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>和强引用对比，弱引用不会对其引用的实例保持强引用，这一特性阻止了变成循环强引用的端倪。  </p>
<p>弱引用必须被声明为变量，而且可以没有值，我们还是依照上面的那个例子，但是这次Apartment类有些改动：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class Apartment &#123;</div><div class="line">    let unit: String</div><div class="line">    weak var person: Person?</div><div class="line"></div><div class="line">    init (unit: String) &#123;</div><div class="line">        self.unit = unit</div><div class="line">        print(&quot;\(unit)正在被初始化&quot;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;\(unit)正在被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将person设为weak类型，然后将变量指向nil。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">per = nil</div><div class="line">apart = nil</div></pre></td></tr></table></figure>
<p>我们会发现，这次执行了销毁方法，打印出了log，说明循环引用被我们打破了。  </p>
<h4 id="无主引用"><a href="#无主引用" class="headerlink" title="无主引用"></a>无主引用</h4><p>和弱引用不同的是，弱引用是没有值时也可以用，无主引用时要保证总是有值。因此，无主引用一般总是被定义为非可选类型。判断到底是用弱引用还是无主引用，只要根据该引用是可选类型的还是非可选类型的。</p>
<h3 id="闭包引起的循环引用"><a href="#闭包引起的循环引用" class="headerlink" title="闭包引起的循环引用"></a>闭包引起的循环引用</h3><p>在真实的开发中，很多循环引用都发生在此，那么为什么会发生呢？我们以一个例子作为参考，先实现一个简单的HTML类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很简单，类中包括一个闭包，是根据属性值来返回不同的数据。然后我们实现一个变量来引用 <code>HTMLElement</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var paragraph: HTMLElement? = HTMLElement(name: &quot;p&quot;, text: &quot;hello world&quot;)</div><div class="line">print(paragraph!.asHTML())</div></pre></td></tr></table></figure>
<p>可以看到，屏幕上打印出了<code>&lt;p&gt;hello world&lt;/p&gt;</code>字样，然后我们对变量赋值<code>nil</code>，取消引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">paragraph = nil</div></pre></td></tr></table></figure>
<p>我们发现，并没有调用类的销毁方法，说明出现了循环引用。那么此处的循环引用是怎么出现的呢？  </p>
<p>首先说明，出现强引用的是闭包和引用实例两者，闭包其实和类相似，都是引用类型。实例<code>paragraph</code>持有闭包的引用，而闭包中又使用了<code>self</code>，因此闭包捕获了<code>self</code>，这意味着闭包又反过来持有了<code>HTMLElement</code>实例的强引用，这样两个对象就产生了循环强引用。</p>
<h3 id="解决闭包引起的循环引用"><a href="#解决闭包引起的循环引用" class="headerlink" title="解决闭包引起的循环引用"></a>解决闭包引起的循环引用</h3><p>那么如何解决呢？在Objective-C中，解决办法是外部将<code>self</code>设为<code>weak</code>类型，从而保证闭包内捕获<code>self</code>时不会发生强引用。那么在Swift中，解决的办法也类似。  </p>
<p>只不过分为弱引用和无主引用两种，和上面类似，弱引用是针对可选类型的，而无主引用是针对非可选类型的。在这个例子中，使用无主引用比较恰当。我们修改<code>HTMLElement</code>类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class HTMLElement &#123;</div><div class="line"></div><div class="line">    let name: String</div><div class="line">    let text: String?</div><div class="line"></div><div class="line">    lazy var asHTML: Void -&gt; String = &#123;</div><div class="line">        [unowned self] in</div><div class="line">        if let text = self.text &#123;</div><div class="line">            return &quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</div><div class="line">        &#125;else &#123;</div><div class="line">            return &quot;&lt;\(self.name) /&gt;&quot;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    init(name: String, text: String? = nil) &#123;</div><div class="line">        self.name = name</div><div class="line">        self.text = text</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        print(&quot;HTMLElement对象被销毁&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了不发生循环引用，我们在闭包中使用无主引用来捕获<code>self</code>，这样将实例设为<code>nil</code>，我们发现屏幕上打印出了<code>HTMLElement对象被销毁</code>。说明我们解决问题了。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/04/21/Swift学习之闭包/" class="prev">PREV</a><a href="/2016/03/24/Swift学习之枚举、类和结构体/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'hyyyblog';
var disqus_identifier = '2016/04/05/Swift之自动引用计数/';
var disqus_title = 'Swift之自动引用计数';
var disqus_url = 'http://yoursite.com/2016/04/05/Swift之自动引用计数/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//hyyyblog.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">Hyyy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>